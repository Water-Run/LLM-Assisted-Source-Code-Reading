/* =============================================================================
 * 文件概述 (Overview)
 * =============================================================================
 * 
 * 这是一个 TypeScript 类型声明文件 (.d.ts)，由 `unplugin-auto-import` 插件自动生成。
 * 
 * 【这个文件解决什么问题？】
 * 在正常的 Vue 项目中，你每次使用 ref、computed、watch 等函数时，都需要手动写 import 语句：
 *   import { ref, computed, watch } from 'vue'
 * 
 * 这很繁琐！`unplugin-auto-import` 插件可以让你直接使用这些函数，无需手动导入。
 * 但问题是：TypeScript 不知道这些"凭空出现"的函数是什么，会报错说"找不到 ref"。
 * 
 * 【这个文件的作用】
 * 这个文件就是告诉 TypeScript："别担心，ref、computed 这些函数确实存在，
 * 它们来自 'vue' 包，类型是这样的..."
 * 
 * 【你需要手动修改这个文件吗？】
 * 不需要！这个文件是构建工具自动生成和更新的。
 * 你只需要知道它的存在，理解它的作用即可。
 * 
 * =============================================================================
 */

/* eslint-disable */
// ↑ 告诉 ESLint（代码检查工具）：不要检查这个文件
//   因为这是自动生成的，格式可能不符合常规规则

/* prettier-ignore */
// ↑ 告诉 Prettier（代码格式化工具）：不要格式化这个文件
//   保持生成时的原始格式

// @ts-nocheck
// ↑ 告诉 TypeScript：不要对这个文件进行严格的类型检查
//   因为这里有一些特殊的类型声明方式

// noinspection JSUnusedGlobalSymbols
// ↑ 告诉 JetBrains IDE（如 WebStorm）：不要警告"未使用的全局符号"
//   这些声明虽然在这个文件里没被使用，但会在其他文件中使用

// Generated by unplugin-auto-import
// ↑ 标记：此文件由 unplugin-auto-import 插件生成

export { }
// ↑ 这行看起来奇怪，但很重要！
//   它把这个文件变成一个 ES 模块（而不是普通脚本）
//   这样下面的 `declare global` 才能正确地扩展全局作用域


/* =============================================================================
 * 第一部分：全局变量声明
 * =============================================================================
 * 
 * 下面的 `declare global` 块告诉 TypeScript：
 * "以下这些变量/函数可以在全局作用域中直接使用，不需要 import"
 * 
 * 语法解释：
 * - `declare` = 声明（告诉 TS 这个东西存在，但不是在这里定义的）
 * - `global` = 全局作用域
 * - `const xxx: typeof import('vue')['xxx']` = 
 *     xxx 这个常量的类型，等同于从 'vue' 包导入的 xxx 的类型
 * 
 * =============================================================================
 */

declare global {

  /* ---------------------------------------------------------------------------
   * Vue 核心 API - 响应式系统基础
   * ---------------------------------------------------------------------------
   * 这些是 Vue 3 最常用的响应式 API
   */

  const EffectScope: typeof import('vue')['EffectScope']
  // ↑ EffectScope（效果作用域）
  //   用于创建一个作用域，可以批量管理和清理响应式副作用
  //   高级用法，初学者暂时不需要关注

  const computed: typeof import('vue')['computed']
  // ↑ computed（计算属性）
  //   用于创建一个基于其他响应式数据计算得出的值
  //   例如：const fullName = computed(() => firstName.value + ' ' + lastName.value)
  //   当 firstName 或 lastName 变化时，fullName 会自动更新

  const ref: typeof import('vue')['ref']
  // ↑ ref（引用）- Vue 3 最常用的 API！
  //   用于创建一个响应式的数据引用
  //   例如：const count = ref(0)
  //   读取值：count.value
  //   修改值：count.value = 1（会自动触发界面更新）

  const reactive: typeof import('vue')['reactive']
  // ↑ reactive（响应式对象）
  //   用于创建一个响应式的对象
  //   例如：const state = reactive({ name: 'John', age: 25 })
  //   与 ref 不同，reactive 不需要 .value，直接用 state.name
  //   但只能用于对象，不能用于基本类型（数字、字符串等）

  const readonly: typeof import('vue')['readonly']
  // ↑ readonly（只读）
  //   创建一个只读的响应式对象，尝试修改会在控制台警告
  //   用于防止数据被意外修改

  const shallowRef: typeof import('vue')['shallowRef']
  // ↑ shallowRef（浅层引用）
  //   只有 .value 本身是响应式的，内部嵌套的对象不是响应式的
  //   用于性能优化，当你有很大的对象但只关心整体替换时使用

  const shallowReactive: typeof import('vue')['shallowReactive']
  // ↑ shallowReactive（浅层响应式）
  //   只有对象的第一层属性是响应式的，嵌套对象不是
  //   同样用于性能优化

  const shallowReadonly: typeof import('vue')['shallowReadonly']
  // ↑ shallowReadonly（浅层只读）
  //   只有第一层是只读的，嵌套对象仍可修改

  /* ---------------------------------------------------------------------------
   * Vue 核心 API - 响应式工具函数
   * ---------------------------------------------------------------------------
   * 这些函数用于操作和检查响应式数据
   */

  const toRef: typeof import('vue')['toRef']
  // ↑ toRef（转为引用）
  //   从响应式对象中提取单个属性作为 ref
  //   例如：const nameRef = toRef(state, 'name')
  //   这样 nameRef 和 state.name 会保持同步

  const toRefs: typeof import('vue')['toRefs']
  // ↑ toRefs（转为多个引用）
  //   将响应式对象的所有属性都转为 ref
  //   常用于解构响应式对象时保持响应性：
  //   const { name, age } = toRefs(state)

  const toRaw: typeof import('vue')['toRaw']
  // ↑ toRaw（获取原始对象）
  //   返回响应式对象的原始版本（非响应式）
  //   当你需要把数据传给不理解响应式的第三方库时有用

  const toValue: typeof import('vue')['toValue']
  // ↑ toValue（获取值）
  //   统一的方式获取 ref 或 getter 函数的值
  //   例如：toValue(countRef) 或 toValue(() => count)

  const unref: typeof import('vue')['unref']
  // ↑ unref（解除引用）
  //   如果参数是 ref，返回 .value；否则返回参数本身
  //   例如：unref(count) 相当于 count.value
  //   当你不确定一个值是否是 ref 时很有用

  const isRef: typeof import('vue')['isRef']
  // ↑ isRef（是否是 ref）
  //   检查一个值是否是 ref 对象
  //   例如：isRef(count) // true or false

  const isReactive: typeof import('vue')['isReactive']
  // ↑ isReactive（是否是响应式对象）
  //   检查一个对象是否是 reactive() 创建的

  const isReadonly: typeof import('vue')['isReadonly']
  // ↑ isReadonly（是否只读）
  //   检查一个对象是否是只读的

  const isProxy: typeof import('vue')['isProxy']
  // ↑ isProxy（是否是代理）
  //   检查一个对象是否是 Vue 创建的响应式代理
  //   包括 reactive 和 readonly 创建的对象

  const markRaw: typeof import('vue')['markRaw']
  // ↑ markRaw（标记为原始）
  //   标记一个对象，使其永远不会被转为响应式
  //   例如：第三方类实例不应该被响应式化

  const customRef: typeof import('vue')['customRef']
  // ↑ customRef（自定义 ref）
  //   创建一个自定义的 ref，可以控制依赖追踪和更新触发的时机
  //   高级用法，可用于实现防抖 ref 等

  const triggerRef: typeof import('vue')['triggerRef']
  // ↑ triggerRef（触发 ref 更新）
  //   手动触发 shallowRef 的更新
  //   当你修改了 shallowRef 内部的嵌套对象时，需要手动触发

  const effectScope: typeof import('vue')['effectScope']
  // ↑ effectScope（创建效果作用域）
  //   创建一个可以批量停止的副作用作用域
  //   高级用法，用于可组合函数

  const getCurrentScope: typeof import('vue')['getCurrentScope']
  // ↑ getCurrentScope（获取当前作用域）
  //   获取当前活动的效果作用域

  const onScopeDispose: typeof import('vue')['onScopeDispose']
  // ↑ onScopeDispose（作用域销毁时）
  //   注册一个回调，在当前作用域销毁时调用

  /* ---------------------------------------------------------------------------
   * Vue 核心 API - 应用实例
   * ---------------------------------------------------------------------------
   */

  const createApp: typeof import('vue')['createApp']
  // ↑ createApp（创建应用）
  //   创建一个 Vue 应用实例，是每个 Vue 应用的起点
  //   例如：createApp(App).mount('#app')

  const h: typeof import('vue')['h']
  // ↑ h（创建虚拟节点）
  //   渲染函数的核心，用于创建虚拟 DOM 节点
  //   例如：h('div', { class: 'container' }, 'Hello')
  //   通常在 JSX 或渲染函数中使用

  const resolveComponent: typeof import('vue')['resolveComponent']
  // ↑ resolveComponent（解析组件）
  //   在渲染函数中通过名字获取已注册的组件

  /* ---------------------------------------------------------------------------
   * Vue 核心 API - 组件定义
   * ---------------------------------------------------------------------------
   */

  const defineComponent: typeof import('vue')['defineComponent']
  // ↑ defineComponent（定义组件）
  //   用于定义一个 Vue 组件，主要用于获得 TypeScript 类型推断
  //   例如：export default defineComponent({ ... })

  const defineAsyncComponent: typeof import('vue')['defineAsyncComponent']
  // ↑ defineAsyncComponent（定义异步组件）
  //   创建一个异步加载的组件，可用于代码分割/懒加载
  //   例如：const AsyncComp = defineAsyncComponent(() => import('./MyComp.vue'))

  const getCurrentInstance: typeof import('vue')['getCurrentInstance']
  // ↑ getCurrentInstance（获取当前组件实例）
  //   在 setup() 中获取当前组件实例
  //   主要用于高级场景和库开发

  /* ---------------------------------------------------------------------------
   * Vue 核心 API - 生命周期钩子
   * ---------------------------------------------------------------------------
   * 生命周期钩子让你在组件生命的不同阶段执行代码
   * 这些以 "on" 开头的函数在 setup() 中使用
   */

  const onBeforeMount: typeof import('vue')['onBeforeMount']
  // ↑ onBeforeMount（挂载前）
  //   组件即将被挂载到 DOM 之前调用
  //   此时 DOM 还没有渲染

  const onMounted: typeof import('vue')['onMounted']
  // ↑ onMounted（挂载后）- 最常用的钩子之一！
  //   组件已经挂载到 DOM 后调用
  //   常用于：获取 DOM 元素、发起 API 请求、初始化第三方库
  //   例如：onMounted(() => { console.log('组件已挂载') })

  const onBeforeUpdate: typeof import('vue')['onBeforeUpdate']
  // ↑ onBeforeUpdate（更新前）
  //   响应式数据变化，DOM 更新之前调用

  const onUpdated: typeof import('vue')['onUpdated']
  // ↑ onUpdated（更新后）
  //   DOM 更新完成后调用
  //   注意：不要在这里修改状态，可能导致无限循环

  const onBeforeUnmount: typeof import('vue')['onBeforeUnmount']
  // ↑ onBeforeUnmount（卸载前）
  //   组件即将被卸载之前调用
  //   常用于：清理定时器、取消订阅等

  const onUnmounted: typeof import('vue')['onUnmounted']
  // ↑ onUnmounted（卸载后）
  //   组件已经被卸载后调用
  //   用于最终的清理工作

  const onActivated: typeof import('vue')['onActivated']
  // ↑ onActivated（激活时）
  //   配合 <KeepAlive> 使用，当缓存的组件重新激活时调用

  const onDeactivated: typeof import('vue')['onDeactivated']
  // ↑ onDeactivated（停用时）
  //   配合 <KeepAlive> 使用，当组件被缓存（停用）时调用

  const onErrorCaptured: typeof import('vue')['onErrorCaptured']
  // ↑ onErrorCaptured（捕获错误）
  //   捕获来自后代组件的错误
  //   可用于错误处理和上报

  const onRenderTracked: typeof import('vue')['onRenderTracked']
  // ↑ onRenderTracked（渲染追踪）- 仅开发模式
  //   当组件渲染时追踪到响应式依赖时调用
  //   用于调试，了解组件依赖了哪些数据

  const onRenderTriggered: typeof import('vue')['onRenderTriggered']
  // ↑ onRenderTriggered（渲染触发）- 仅开发模式
  //   当响应式数据变化触发组件重新渲染时调用
  //   用于调试，了解什么数据变化导致了重新渲染

  const onServerPrefetch: typeof import('vue')['onServerPrefetch']
  // ↑ onServerPrefetch（服务端预取）
  //   仅在服务端渲染（SSR）时调用
  //   用于在服务端渲染前获取异步数据

  /* ---------------------------------------------------------------------------
   * Vue 核心 API - 侦听器
   * ---------------------------------------------------------------------------
   * 用于监听响应式数据的变化并执行副作用
   */

  const watch: typeof import('vue')['watch']
  // ↑ watch（侦听）- 非常常用！
  //   监听一个或多个响应式数据源，数据变化时执行回调
  //   例如：watch(count, (newVal, oldVal) => { ... })
  //   可以获取变化前后的值

  const watchEffect: typeof import('vue')['watchEffect']
  // ↑ watchEffect（侦听效果）- 也很常用！
  //   自动追踪回调函数中使用的响应式依赖
  //   例如：watchEffect(() => console.log(count.value))
  //   当 count 变化时，会自动重新执行
  //   与 watch 的区别：不需要指定要监听什么，自动检测

  const watchPostEffect: typeof import('vue')['watchPostEffect']
  // ↑ watchPostEffect（DOM 更新后的侦听效果）
  //   等同于 watchEffect 加上 { flush: 'post' } 选项
  //   回调会在 DOM 更新后执行

  const watchSyncEffect: typeof import('vue')['watchSyncEffect']
  // ↑ watchSyncEffect（同步侦听效果）
  //   等同于 watchEffect 加上 { flush: 'sync' } 选项
  //   回调会同步执行（在数据变化时立即执行，DOM 更新前）
  //   小心使用，可能影响性能

  /* ---------------------------------------------------------------------------
   * Vue 核心 API - 依赖注入
   * ---------------------------------------------------------------------------
   * 用于跨组件层级传递数据，避免 props 层层传递
   */

  const provide: typeof import('vue')['provide']
  // ↑ provide（提供）
  //   在祖先组件中提供数据
  //   例如：provide('theme', 'dark')
  //   所有后代组件都可以注入这个数据

  const inject: typeof import('vue')['inject']
  // ↑ inject（注入）
  //   在后代组件中注入祖先提供的数据
  //   例如：const theme = inject('theme')

  /* ---------------------------------------------------------------------------
   * Vue 核心 API - 工具函数
   * ---------------------------------------------------------------------------
   */

  const nextTick: typeof import('vue')['nextTick']
  // ↑ nextTick（下一个时刻）- 常用！
  //   等待下一次 DOM 更新刷新后执行回调
  //   例如：修改数据后想立即获取更新后的 DOM
  //   await nextTick()
  //   console.log(element.textContent)

  const useAttrs: typeof import('vue')['useAttrs']
  // ↑ useAttrs（获取属性）
  //   在 setup() 中获取传递给组件的属性（非 props）

  const useSlots: typeof import('vue')['useSlots']
  // ↑ useSlots（获取插槽）
  //   在 setup() 中获取组件的插槽

  const useCssModule: typeof import('vue')['useCssModule']
  // ↑ useCssModule（使用 CSS 模块）
  //   在 setup() 中访问 CSS Modules

  const useCssVars: typeof import('vue')['useCssVars']
  // ↑ useCssVars（使用 CSS 变量）
  //   将响应式数据注入为 CSS 变量

  /* ---------------------------------------------------------------------------
   * Pinia 状态管理 API
   * ---------------------------------------------------------------------------
   * Pinia 是 Vue 官方推荐的状态管理库（Vuex 的继任者）
   * 用于在多个组件间共享状态
   */

  const acceptHMRUpdate: typeof import('pinia')['acceptHMRUpdate']
  // ↑ acceptHMRUpdate（接受热更新）
  //   让 store 支持热模块替换（HMR）
  //   开发时修改 store 代码后页面不会完全刷新

  const createPinia: typeof import('pinia')['createPinia']
  // ↑ createPinia（创建 Pinia 实例）
  //   创建 Pinia 状态管理实例，用于 app.use(pinia)

  const defineStore: typeof import('pinia')['defineStore']
  // ↑ defineStore（定义 Store）- Pinia 最核心的 API！
  //   定义一个状态仓库
  //   例如：
  //   const useUserStore = defineStore('user', {
  //     state: () => ({ name: '', age: 0 }),
  //     actions: { ... }
  //   })

  const getActivePinia: typeof import('pinia')['getActivePinia']
  // ↑ getActivePinia（获取当前活跃的 Pinia）
  //   获取当前激活的 Pinia 实例

  const setActivePinia: typeof import('pinia')['setActivePinia']
  // ↑ setActivePinia（设置活跃的 Pinia）
  //   设置当前活跃的 Pinia 实例，主要用于测试

  const setMapStoreSuffix: typeof import('pinia')['setMapStoreSuffix']
  // ↑ setMapStoreSuffix（设置 mapStores 后缀）
  //   配置 mapStores 使用的后缀（默认是 'Store'）

  const storeToRefs: typeof import('pinia')['storeToRefs']
  // ↑ storeToRefs（Store 转 Refs）- 常用！
  //   从 store 中提取响应式属性作为 refs
  //   这样解构 store 时仍保持响应性
  //   例如：const { name, age } = storeToRefs(userStore)

  // 以下是 Options API 风格的辅助函数，用于选项式组件
  const mapActions: typeof import('pinia')['mapActions']
  // ↑ 映射 store 的 actions 到组件方法

  const mapGetters: typeof import('pinia')['mapGetters']
  // ↑ 映射 store 的 getters 到组件计算属性

  const mapState: typeof import('pinia')['mapState']
  // ↑ 映射 store 的 state 到组件计算属性（只读）

  const mapStores: typeof import('pinia')['mapStores']
  // ↑ 映射整个 store 到组件

  const mapWritableState: typeof import('pinia')['mapWritableState']
  // ↑ 映射 store 的 state 到组件（可写）

  /* ---------------------------------------------------------------------------
   * Vue Router 路由 API
   * ---------------------------------------------------------------------------
   * Vue Router 是 Vue 官方的路由管理器
   * 用于在单页应用中实现页面导航
   * 
   * 注意：这里使用的是 'vue-router/auto'，这是支持文件系统路由的版本
   */

  const useRoute: typeof import('vue-router/auto')['useRoute']
  // ↑ useRoute（获取当前路由）- 非常常用！
  //   获取当前路由的信息
  //   例如：const route = useRoute()
  //   route.params.id  // 路由参数
  //   route.query.search  // 查询参数
  //   route.path  // 当前路径

  const useRouter: typeof import('vue-router/auto')['useRouter']
  // ↑ useRouter（获取路由器）- 非常常用！
  //   获取路由器实例，用于编程式导航
  //   例如：const router = useRouter()
  //   router.push('/home')  // 跳转到 /home
  //   router.back()  // 后退

  const onBeforeRouteLeave: typeof import('vue-router/auto')['onBeforeRouteLeave']
  // ↑ onBeforeRouteLeave（路由离开前）
  //   在当前路由即将离开时调用
  //   可用于阻止用户离开（如有未保存的表单）

  const onBeforeRouteUpdate: typeof import('vue-router/auto')['onBeforeRouteUpdate']
  // ↑ onBeforeRouteUpdate（路由更新前）
  //   当路由变化但组件被复用时调用（如 /user/1 变为 /user/2）

  const defineLoader: typeof import('vue-router/auto')['defineLoader']
  // ↑ defineLoader（定义数据加载器）
  //   vue-router/auto 特有功能，用于定义路由级别的数据加载

  /* ---------------------------------------------------------------------------
   * unplugin-vue-router 文件系统路由 API
   * ---------------------------------------------------------------------------
   */

  const definePage: typeof import('unplugin-vue-router/runtime')['_definePage']
  // ↑ definePage（定义页面）
  //   在页面组件中定义路由元信息
  //   用于文件系统路由，可以在页面文件中定义路由配置
}


/* =============================================================================
 * 第二部分：类型重新导出
 * =============================================================================
 * 
 * 这部分让一些常用的 Vue 类型也可以在全局使用
 * 这样你在写 TypeScript 时不需要单独 import 这些类型
 * 
 * =============================================================================
 */

// for type re-export
declare global {
  // @ts-ignore
  export type { Component, ComponentPublicInstance, ComputedRef, InjectionKey, PropType, Ref, VNode } from 'vue'
  // ↑ 导出以下类型到全局：
  //   - Component: Vue 组件类型
  //   - ComponentPublicInstance: 组件实例类型
  //   - ComputedRef: computed() 返回值的类型
  //   - InjectionKey: 依赖注入的 key 类型（用于类型安全的 provide/inject）
  //   - PropType: 定义 props 类型的辅助类型
  //   - Ref: ref() 返回值的类型
  //   - VNode: 虚拟 DOM 节点类型
}


/* =============================================================================
 * 第三部分：Vue 模板中的自动导入
 * =============================================================================
 * 
 * 这部分是为了让这些 API 也能在 Vue 模板（<template>）中使用
 * 
 * 通过扩展 Vue 的 ComponentCustomProperties 接口，
 * TypeScript 就知道这些属性可以在模板中通过 this 访问
 * 
 * 例如在模板中可以直接使用 {{ $route.params.id }}
 * 
 * =============================================================================
 */

// for vue template auto import
import { UnwrapRef } from 'vue'
// ↑ UnwrapRef 是一个工具类型，用于解包 Ref 类型
//   比如 UnwrapRef<Ref<number>> = number

declare module 'vue' {
  // ↑ 这里使用了 TypeScript 的"模块增强"（Module Augmentation）
  //   意思是：扩展 'vue' 模块的类型定义，添加新的属性

  interface ComponentCustomProperties {
    // ↑ ComponentCustomProperties 是 Vue 定义的接口
    //   用于描述组件实例上可用的自定义属性
    //   我们在这里添加的属性，在 Vue 模板中就可以直接使用

    // 下面的 readonly 表示这些属性是只读的，不能被修改
    // UnwrapRef<...> 确保类型正确（解包 Ref 类型）

    readonly EffectScope: UnwrapRef<typeof import('vue')['EffectScope']>
    readonly acceptHMRUpdate: UnwrapRef<typeof import('pinia')['acceptHMRUpdate']>
    readonly computed: UnwrapRef<typeof import('vue')['computed']>
    readonly createApp: UnwrapRef<typeof import('vue')['createApp']>
    readonly createPinia: UnwrapRef<typeof import('pinia')['createPinia']>
    readonly customRef: UnwrapRef<typeof import('vue')['customRef']>
    readonly defineAsyncComponent: UnwrapRef<typeof import('vue')['defineAsyncComponent']>
    readonly defineComponent: UnwrapRef<typeof import('vue')['defineComponent']>
    readonly defineLoader: UnwrapRef<typeof import('vue-router/auto')['defineLoader']>
    readonly definePage: UnwrapRef<typeof import('unplugin-vue-router/runtime')['_definePage']>
    readonly defineStore: UnwrapRef<typeof import('pinia')['defineStore']>
    readonly effectScope: UnwrapRef<typeof import('vue')['effectScope']>
    readonly getActivePinia: UnwrapRef<typeof import('pinia')['getActivePinia']>
    readonly getCurrentInstance: UnwrapRef<typeof import('vue')['getCurrentInstance']>
    readonly getCurrentScope: UnwrapRef<typeof import('vue')['getCurrentScope']>
    readonly h: UnwrapRef<typeof import('vue')['h']>
    readonly inject: UnwrapRef<typeof import('vue')['inject']>
    readonly isProxy: UnwrapRef<typeof import('vue')['isProxy']>
    readonly isReactive: UnwrapRef<typeof import('vue')['isReactive']>
    readonly isReadonly: UnwrapRef<typeof import('vue')['isReadonly']>
    readonly isRef: UnwrapRef<typeof import('vue')['isRef']>
    readonly mapActions: UnwrapRef<typeof import('pinia')['mapActions']>
    readonly mapGetters: UnwrapRef<typeof import('pinia')['mapGetters']>
    readonly mapState: UnwrapRef<typeof import('pinia')['mapState']>
    readonly mapStores: UnwrapRef<typeof import('pinia')['mapStores']>
    readonly mapWritableState: UnwrapRef<typeof import('pinia')['mapWritableState']>
    readonly markRaw: UnwrapRef<typeof import('vue')['markRaw']>
    readonly nextTick: UnwrapRef<typeof import('vue')['nextTick']>
    readonly onActivated: UnwrapRef<typeof import('vue')['onActivated']>
    readonly onBeforeMount: UnwrapRef<typeof import('vue')['onBeforeMount']>
    readonly onBeforeRouteLeave: UnwrapRef<typeof import('vue-router/auto')['onBeforeRouteLeave']>
    readonly onBeforeRouteUpdate: UnwrapRef<typeof import('vue-router/auto')['onBeforeRouteUpdate']>
    readonly onBeforeUnmount: UnwrapRef<typeof import('vue')['onBeforeUnmount']>
    readonly onBeforeUpdate: UnwrapRef<typeof import('vue')['onBeforeUpdate']>
    readonly onDeactivated: UnwrapRef<typeof import('vue')['onDeactivated']>
    readonly onErrorCaptured: UnwrapRef<typeof import('vue')['onErrorCaptured']>
    readonly onMounted: UnwrapRef<typeof import('vue')['onMounted']>
    readonly onRenderTracked: UnwrapRef<typeof import('vue')['onRenderTracked']>
    readonly onRenderTriggered: UnwrapRef<typeof import('vue')['onRenderTriggered']>
    readonly onScopeDispose: UnwrapRef<typeof import('vue')['onScopeDispose']>
    readonly onServerPrefetch: UnwrapRef<typeof import('vue')['onServerPrefetch']>
    readonly onUnmounted: UnwrapRef<typeof import('vue')['onUnmounted']>
    readonly onUpdated: UnwrapRef<typeof import('vue')['onUpdated']>
    readonly provide: UnwrapRef<typeof import('vue')['provide']>
    readonly reactive: UnwrapRef<typeof import('vue')['reactive']>
    readonly readonly: UnwrapRef<typeof import('vue')['readonly']>
    readonly ref: UnwrapRef<typeof import('vue')['ref']>
    readonly resolveComponent: UnwrapRef<typeof import('vue')['resolveComponent']>
    readonly setActivePinia: UnwrapRef<typeof import('pinia')['setActivePinia']>
    readonly setMapStoreSuffix: UnwrapRef<typeof import('pinia')['setMapStoreSuffix']>
    readonly shallowReactive: UnwrapRef<typeof import('vue')['shallowReactive']>
    readonly shallowReadonly: UnwrapRef<typeof import('vue')['shallowReadonly']>
    readonly shallowRef: UnwrapRef<typeof import('vue')['shallowRef']>
    readonly storeToRefs: UnwrapRef<typeof import('pinia')['storeToRefs']>
    readonly toRaw: UnwrapRef<typeof import('vue')['toRaw']>
    readonly toRef: UnwrapRef<typeof import('vue')['toRef']>
    readonly toRefs: UnwrapRef<typeof import('vue')['toRefs']>
    readonly toValue: UnwrapRef<typeof import('vue')['toValue']>
    readonly triggerRef: UnwrapRef<typeof import('vue')['triggerRef']>
    readonly unref: UnwrapRef<typeof import('vue')['unref']>
    readonly useAttrs: UnwrapRef<typeof import('vue')['useAttrs']>
    readonly useCssModule: UnwrapRef<typeof import('vue')['useCssModule']>
    readonly useCssVars: UnwrapRef<typeof import('vue')['useCssVars']>
    readonly useRoute: UnwrapRef<typeof import('vue-router/auto')['useRoute']>
    readonly useRouter: UnwrapRef<typeof import('vue-router/auto')['useRouter']>
    readonly useSlots: UnwrapRef<typeof import('vue')['useSlots']>
    readonly watch: UnwrapRef<typeof import('vue')['watch']>
    readonly watchEffect: UnwrapRef<typeof import('vue')['watchEffect']>
    readonly watchPostEffect: UnwrapRef<typeof import('vue')['watchPostEffect']>
    readonly watchSyncEffect: UnwrapRef<typeof import('vue')['watchSyncEffect']>
  }
}


/* =============================================================================
 * 第四部分：Vue Runtime Core 的类型扩展
 * =============================================================================
 * 
 * 这部分与上面类似，但是针对 '@vue/runtime-core' 模块
 * 
 * 为什么需要这个？
 * Vue 的类型系统有时会从 '@vue/runtime-core' 读取类型定义
 * 为了确保完整的类型支持，这里也做了同样的扩展
 * 
 * =============================================================================
 */

declare module '@vue/runtime-core' {
  interface ComponentCustomProperties {
    // 这里的内容与上面 'vue' 模块中的完全相同
    // 是为了确保类型系统的完整性

    readonly EffectScope: UnwrapRef<typeof import('vue')['EffectScope']>
    readonly acceptHMRUpdate: UnwrapRef<typeof import('pinia')['acceptHMRUpdate']>
    readonly computed: UnwrapRef<typeof import('vue')['computed']>
    readonly createApp: UnwrapRef<typeof import('vue')['createApp']>
    readonly createPinia: UnwrapRef<typeof import('pinia')['createPinia']>
    readonly customRef: UnwrapRef<typeof import('vue')['customRef']>
    readonly defineAsyncComponent: UnwrapRef<typeof import('vue')['defineAsyncComponent']>
    readonly defineComponent: UnwrapRef<typeof import('vue')['defineComponent']>
    readonly defineLoader: UnwrapRef<typeof import('vue-router/auto')['defineLoader']>
    readonly definePage: UnwrapRef<typeof import('unplugin-vue-router/runtime')['_definePage']>
    readonly defineStore: UnwrapRef<typeof import('pinia')['defineStore']>
    readonly effectScope: UnwrapRef<typeof import('vue')['effectScope']>
    readonly getActivePinia: UnwrapRef<typeof import('pinia')['getActivePinia']>
    readonly getCurrentInstance: UnwrapRef<typeof import('vue')['getCurrentInstance']>
    readonly getCurrentScope: UnwrapRef<typeof import('vue')['getCurrentScope']>
    readonly h: UnwrapRef<typeof import('vue')['h']>
    readonly inject: UnwrapRef<typeof import('vue')['inject']>
    readonly isProxy: UnwrapRef<typeof import('vue')['isProxy']>
    readonly isReactive: UnwrapRef<typeof import('vue')['isReactive']>
    readonly isReadonly: UnwrapRef<typeof import('vue')['isReadonly']>
    readonly isRef: UnwrapRef<typeof import('vue')['isRef']>
    readonly mapActions: UnwrapRef<typeof import('pinia')['mapActions']>
    readonly mapGetters: UnwrapRef<typeof import('pinia')['mapGetters']>
    readonly mapState: UnwrapRef<typeof import('pinia')['mapState']>
    readonly mapStores: UnwrapRef<typeof import('pinia')['mapStores']>
    readonly mapWritableState: UnwrapRef<typeof import('pinia')['mapWritableState']>
    readonly markRaw: UnwrapRef<typeof import('vue')['markRaw']>
    readonly nextTick: UnwrapRef<typeof import('vue')['nextTick']>
    readonly onActivated: UnwrapRef<typeof import('vue')['onActivated']>
    readonly onBeforeMount: UnwrapRef<typeof import('vue')['onBeforeMount']>
    readonly onBeforeRouteLeave: UnwrapRef<typeof import('vue-router/auto')['onBeforeRouteLeave']>
    readonly onBeforeRouteUpdate: UnwrapRef<typeof import('vue-router/auto')['onBeforeRouteUpdate']>
    readonly onBeforeUnmount: UnwrapRef<typeof import('vue')['onBeforeUnmount']>
    readonly onBeforeUpdate: UnwrapRef<typeof import('vue')['onBeforeUpdate']>
    readonly onDeactivated: UnwrapRef<typeof import('vue')['onDeactivated']>
    readonly onErrorCaptured: UnwrapRef<typeof import('vue')['onErrorCaptured']>
    readonly onMounted: UnwrapRef<typeof import('vue')['onMounted']>
    readonly onRenderTracked: UnwrapRef<typeof import('vue')['onRenderTracked']>
    readonly onRenderTriggered: UnwrapRef<typeof import('vue')['onRenderTriggered']>
    readonly onScopeDispose: UnwrapRef<typeof import('vue')['onScopeDispose']>
    readonly onServerPrefetch: UnwrapRef<typeof import('vue')['onServerPrefetch']>
    readonly onUnmounted: UnwrapRef<typeof import('vue')['onUnmounted']>
    readonly onUpdated: UnwrapRef<typeof import('vue')['onUpdated']>
    readonly provide: UnwrapRef<typeof import('vue')['provide']>
    readonly reactive: UnwrapRef<typeof import('vue')['reactive']>
    readonly readonly: UnwrapRef<typeof import('vue')['readonly']>
    readonly ref: UnwrapRef<typeof import('vue')['ref']>
    readonly resolveComponent: UnwrapRef<typeof import('vue')['resolveComponent']>
    readonly setActivePinia: UnwrapRef<typeof import('pinia')['setActivePinia']>
    readonly setMapStoreSuffix: UnwrapRef<typeof import('pinia')['setMapStoreSuffix']>
    readonly shallowReactive: UnwrapRef<typeof import('vue')['shallowReactive']>
    readonly shallowReadonly: UnwrapRef<typeof import('vue')['shallowReadonly']>
    readonly shallowRef: UnwrapRef<typeof import('vue')['shallowRef']>
    readonly storeToRefs: UnwrapRef<typeof import('pinia')['storeToRefs']>
    readonly toRaw: UnwrapRef<typeof import('vue')['toRaw']>
    readonly toRef: UnwrapRef<typeof import('vue')['toRef']>
    readonly toRefs: UnwrapRef<typeof import('vue')['toRefs']>
    readonly toValue: UnwrapRef<typeof import('vue')['toValue']>
    readonly triggerRef: UnwrapRef<typeof import('vue')['triggerRef']>
    readonly unref: UnwrapRef<typeof import('vue')['unref']>
    readonly useAttrs: UnwrapRef<typeof import('vue')['useAttrs']>
    readonly useCssModule: UnwrapRef<typeof import('vue')['useCssModule']>
    readonly useCssVars: UnwrapRef<typeof import('vue')['useCssVars']>
    readonly useRoute: UnwrapRef<typeof import('vue-router/auto')['useRoute']>
    readonly useRouter: UnwrapRef<typeof import('vue-router/auto')['useRouter']>
    readonly useSlots: UnwrapRef<typeof import('vue')['useSlots']>
    readonly watch: UnwrapRef<typeof import('vue')['watch']>
    readonly watchEffect: UnwrapRef<typeof import('vue')['watchEffect']>
    readonly watchPostEffect: UnwrapRef<typeof import('vue')['watchPostEffect']>
    readonly watchSyncEffect: UnwrapRef<typeof import('vue')['watchSyncEffect']>
  }
}


/* =============================================================================
 * 文件总结
 * =============================================================================
 * 
 * 【这个文件是什么？】
 * 这是一个 TypeScript 类型声明文件，由 unplugin-auto-import 插件自动生成。
 * 
 * 【它的作用是什么？】
 * 1. 让你可以在代码中直接使用 ref、computed、watch 等函数，无需 import
 * 2. 同时告诉 TypeScript 这些"凭空出现"的函数是合法的、有正确的类型
 * 
 * 【文件结构】
 * 文件分为四个主要部分：
 * 
 * 1. declare global { ... }（全局变量声明）
 *    - 声明所有可以直接使用的 Vue/Pinia/Vue Router API
 *    - 包括：响应式 API、生命周期钩子、侦听器、状态管理、路由等
 * 
 * 2. 类型重新导出
 *    - 导出常用的 Vue 类型（如 Ref、ComputedRef）到全局
 * 
 * 3. declare module 'vue' { ... }
 *    - 扩展 Vue 的类型定义，让这些 API 在模板中也能正确工作
 * 
 * 4. declare module '@vue/runtime-core' { ... }
 *    - 同上，确保类型系统的完整性
 * 
 * 【你需要做什么？】
 * 什么都不需要做！这个文件是自动生成的：
 * - 不要手动编辑它
 * - 它会在构建时自动更新
 * - 只需要确保它被包含在 tsconfig.json 的配置中
 * 
 * 【这些 API 的重要程度】
 * 作为初学者，最需要掌握的是：
 * - ref（最常用的响应式 API）
 * - computed（计算属性）
 * - watch / watchEffect（监听数据变化）
 * - onMounted（生命周期：组件挂载后）
 * - useRoute / useRouter（路由相关）
 * - defineStore / storeToRefs（Pinia 状态管理）
 * 
 * 其他 API 可以在需要时再学习。
 * 
 * =============================================================================
 */