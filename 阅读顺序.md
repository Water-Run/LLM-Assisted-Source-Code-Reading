### Lua 源码阅读计划与文件索引（Zed 友好版）

| 阶段     | 顺序     | 核心文件                     | 模块/类别                            | 功能简介与阅读重点（Key Takeaways）                                                                              |
| ------ | ------ | ------------------------ | -------------------------------- | ----------------------------------------------------------------------------------------------------- |
| **P1** | **1**  | `lobject.h`, `lobject.c` | **对象系统**（Data Representation）    | **全览基石**：定义 `TValue` 与所有 Lua 数据类型。重点看 `CommonHeader` 宏与 Tagged Union 设计，理解动态类型在 C 中的表示方式。             |
| **P1** | **2**  | `lua.h`, `luaconf.h`     | **公共头文件**（Public Header）         | **用户接口**：对外暴露的 API 与配置宏。`luaconf.h` 值得通读，了解 Lua 如何用宏实现高可移植性（ANSI C）。                                  |
| **P2** | **3**  | `lstate.h`, `lstate.c`   | **全局状态**（Global State）           | **上下文环境**：定义 `lua_State`（线程/栈）与 `global_State`（全局）。重点理解栈（Stack）在内存中的布局方式。                             |
| **P2** | **4**  | `lapi.c`                 | **C API 实现**（API Implementation） | **交互桥梁**：实现 `lua_push*`、`lua_get*` 等。重点观察它如何将外部 C 调用映射为内部 VM 栈操作；这也是 Rust/Lua 绑定的底层原理。                |
| **P3** | **5**  | `ltable.h`, `ltable.c`   | **表实现**（Table Implementation）    | **核心算法**：Lua 唯一的复合数据结构。重点学习“数组部分 + 哈希部分”的混合存储策略，以及用于冲突处理的 Brent 算法变体。                                 |
| **P3** | **6**  | `lopcodes.h`, `lvm.c`    | **虚拟机**（Virtual Machine）         | **执行引擎**：`luaV_execute` 是主循环，`lopcodes.h` 定义指令集。重点看大型 `switch-case` 如何解释执行字节码（如 `OP_ADD`, `OP_CALL`）。 |
| **P3** | **7**  | `ldo.c`                  | **函数调用**（Function Calls）         | **控制流**：管理调用栈（Call Stack）与受保护调用（`pcall`）。重点看 `luaD_precall` 与 `luaD_poscall`。                         |
| **P4** | **8**  | `llex.c`, `lparser.c`    | **词法/语法分析**（Lexer & Parser）      | **编译器前端**：手写递归下降解析器（Recursive Descent），无需 Yacc/Bison，代码紧凑；对你的 Markdown 编译器项目很有参考价值。                   |
| **P4** | **9**  | `lcode.c`                | **代码生成**（Code Generator）         | **编译器后端**：Lua 多为边解析边生成，负责生成字节码指令与控制流结构。                                                               |
| **P5** | **10** | `lgc.c`                  | **垃圾回收**（Garbage Collection）     | **内存管理**：增量式标记-清除（Incremental Mark-and-Sweep）。逻辑较复杂，建议进阶阅读。                                           |
| **P6** | **11** | `lauxlib.c`              | **辅助库**（Auxiliary Library）       | **工具集**：实现 `luaL_*` 系列函数。重点看其如何在核心 API（`lapi.c`）之上封装更易用的高级接口。                                         |
| **P6** | **12** | `lua.c`                  | **宿主程序**（Standalone Interpreter） | **CLI 范例**：标准解释器 `lua` 命令的源码。重点看初始化、命令行参数处理与 REPL 循环，作为 CLI 工具开发参考。                                   |
| **P7** | **13** | `l*lib.c`（如 `lstrlib.c`） | **标准库**（Standard Libraries）      | **库实现**：string/io/math 等标准库的 C 实现。可先选熟悉模块（如 string），观察其注册到 Lua 环境的方式。                                 |

---

### 快速参考：文件前缀含义

* `lapi`: Lua API（Core）
* `lauxlib`: Auxiliary Library（Helper functions）
* `lbaselib`: Basic Library（`print`, `type` 等）
* `lcode`: Code Generator
* `ldblib`: Debug Library
* `ldebug`: Debug Interface（Internal）
* `ldo`: Function Calls / Execution Control
* `lfunc`: Function handling（Proto, UpVal）
* `lgc`: Garbage Collector
* `llex`: Lexical Analyzer
* `lmem`: Memory Manager
* `lobject`: Lua Objects（TValue）
* `lopcodes`: Opcodes（VM instructions）
* `lparser`: Parser
* `lstate`: Global State
* `lstring`: String logic
* `ltable`: Table logic
* `lvm`: Virtual Machine
