/*	MiniscriptUnitTest.cs
 * 
 * ============================================================================
 * 【文件概要】
 * ============================================================================
 * 文件名称: MiniscriptUnitTest.cs
 * 所属项目: MiniScript 源码项目
 * 编程语言: C# 
 * 
 * 【主要功能】
 * 这个文件是 MiniScript 项目的单元测试框架入口文件。
 * 它提供了一套简单但实用的单元测试工具方法,用于验证 MiniScript 
 * 架构的各个部分是否正常工作。
 * 
 * 【核心职责】
 * 1. 提供错误报告机制 (ReportError)
 * 2. 提供多种断言方法来验证测试条件
 * 3. 作为整个测试套件的统一入口点
 * 
 * 【设计模式】
 * - 使用静态类和静态方法,无需实例化即可使用
 * - 采用断言模式进行测试验证
 * - 支持跨平台(普通.NET和Unity)的错误输出
 * 
 * 【使用方式】
 * 只需调用 Miniscript.UnitTest.Run() 即可运行所有单元测试
 * 
 * 【原始说明】(保留原注释翻译)
 * 这个文件包含了许多针对MiniScript架构各个部分的单元测试。
 * MiniScript的开发者使用它来确保在进行修改时不会破坏现有功能。
 * 
 * 你可以安全地忽略这个文件,但如果你真的想自己运行测试,
 * 只需调用 Miniscript.UnitTest.Run() 即可。
 * 
 * ============================================================================
 */

// 【using指令说明】
// using System: 引入.NET Framework的核心命名空间
// 这使我们可以使用基本类型如 Console, String 等
using System;

// 【命名空间说明】
// namespace 是C#中用于组织代码的逻辑分组机制
// 这里定义的所有类都属于 Miniscript 命名空间
namespace Miniscript {
	
	// ========================================================================
	// 【类定义】UnitTest - 单元测试工具类
	// ========================================================================
	// 
	// 【修饰符说明】
	// - public: 表示这个类可以被任何其他代码访问
	// - static: 这是一个静态类,意味着:
	//   1) 不能被实例化(不能使用 new UnitTest())
	//   2) 只能包含静态成员(静态方法、静态字段等)
	//   3) 直接通过类名访问,如: UnitTest.Run()
	// 
	// 【为什么使用静态类?】
	// 对于工具类/辅助类来说,使用静态类是最佳实践,因为:
	// - 不需要维护状态(没有实例字段)
	// - 提供的是纯粹的功能性方法
	// - 避免不必要的对象创建开销
	// 
	public static class UnitTest {
		
		// ====================================================================
		// 【方法1】ReportError - 错误报告核心方法
		// ====================================================================
		// 
		// 【功能描述】
		// 这是所有错误报告的中心方法。当任何测试失败时,
		// 最终都会调用这个方法来输出错误信息。
		// 
		// 【参数说明】
		// err: string类型,包含要报告的错误描述信息
		// 
		// 【方法特点】
		// 1. 提供统一的错误输出点
		// 2. 便于调试 - 可以在此设置断点捕获所有测试失败
		// 3. 支持多平台输出(控制台 + Unity编辑器)
		// 
		public static void ReportError(string err) {
			// 【调试技巧】
			// 如果你想在任何单元测试失败时进入调试器,
			// 可以在这里设置断点
			
			// 【Console.WriteLine说明】
			// Console是.NET Framework提供的标准输出类
			// WriteLine方法会将文本输出到控制台并换行
			Console.WriteLine(err);
			
			// 【条件编译说明】
			// #if UNITY_EDITOR 是C#的预处理器指令
			// 只有在定义了UNITY_EDITOR符号时,这段代码才会被编译
			// 
			// 【作用】
			// 当在Unity编辑器中运行时,除了输出到控制台,
			// 还会使用Unity的日志系统输出错误信息
			// 
			// 【高级概念】条件编译
			// 允许根据不同的编译环境包含或排除代码段
			// 常用于跨平台开发
			#if UNITY_EDITOR
			// UnityEngine.Debug.LogError: Unity引擎提供的错误日志方法
			// 会在Unity控制台以红色显示错误信息
			UnityEngine.Debug.LogError("Miniscript unit test failed: " + err);
			#endif
		}

		// ====================================================================
		// 【方法2】ErrorIf - 条件断言方法
		// ====================================================================
		// 
		// 【功能描述】
		// 这是一个基础断言方法。如果提供的条件为真(true),
		// 则认为测试失败,报告错误。
		// 
		// 【参数说明】
		// condition: bool类型,要检查的条件
		// err: string类型,条件为真时要报告的错误信息
		// 
		// 【使用场景示例】
		// ErrorIf(result != expected, "结果不匹配");
		// ErrorIf(list.Count == 0, "列表不应为空");
		// 
		// 【设计模式】
		// 这是"卫语句"(Guard Clause)模式的应用
		// 提前检查异常条件并快速返回
		// 
		public static void ErrorIf(bool condition, string err) {
			// 如果条件为真,报告错误
			// 这是一个简洁的单行if语句,不使用花括号
			if (condition) ReportError(err);
		}

		// ====================================================================
		// 【方法3】ErrorIfNull - 空值检查断言
		// ====================================================================
		// 
		// 【功能描述】
		// 检查对象是否为null。如果为null,则测试失败。
		// 这是测试中最常用的断言之一。
		// 
		// 【参数说明】
		// obj: object类型(C#中所有类型的基类)
		//      可以接受任何引用类型的参数
		// 
		// 【使用场景】
		// 验证某个操作应该返回有效对象而不是null
		// 例如: 
		//   var result = SomeFunction();
		//   ErrorIfNull(result);  // 确保result不为null
		// 
		// 【C#概念】object类型
		// object是所有类型的基类,任何类型都可以隐式转换为object
		// 这使得这个方法具有通用性,可以检查任何类型的null值
		// 
		public static void ErrorIfNull(object obj) {
			// == null: 检查对象引用是否为空
			// null是C#中表示"没有引用任何对象"的特殊值
			if (obj == null) ReportError("Unexpected null");
			// 错误信息: "意外的null值"
		}

		// ====================================================================
		// 【方法4】ErrorIfNotNull - 非空检查断言
		// ====================================================================
		// 
		// 【功能描述】
		// 与ErrorIfNull相反,检查对象是否不为null。
		// 如果对象不为null,则测试失败。
		// 
		// 【参数说明】
		// obj: object类型,要检查的对象
		// 
		// 【使用场景】
		// 验证某个操作应该返回null(表示未找到、失败等)
		// 例如:
		//   var result = FindNonexistentItem();
		//   ErrorIfNotNull(result);  // 期望result为null
		// 
		public static void ErrorIfNotNull(object obj) { 
			// != null: 检查对象引用是否不为空
			if (obj != null) ReportError("Expected null, but got non-null");
			// 错误信息: "期望null,但得到了非null值"
		}

		// ====================================================================
		// 【方法5】ErrorIfNotEqual (字符串重载版本)
		// ====================================================================
		// 
		// 【功能描述】
		// 比较两个字符串是否相等。如果不相等,则测试失败。
		// 
		// 【参数说明】
		// actual: 实际得到的字符串值
		// expected: 期望的字符串值
		// desc: 可选参数,自定义错误描述模板
		// 
		// 【高级C#特性】可选参数(Optional Parameters)
		// desc="Expected {1}, got {0}" 是默认参数值
		// 如果调用时不提供desc参数,就使用这个默认值
		// 
		// 【string.Format说明】
		// string.Format是.NET的字符串格式化方法
		// {0}会被替换为第一个参数(actual)
		// {1}会被替换为第二个参数(expected)
		// 
		// 【使用示例】
		// ErrorIfNotEqual("hello", "world");
		// 输出: "Expected world, got hello"
		// 
		// ErrorIfNotEqual("hello", "world", "不匹配: 实际={0}, 期望={1}");
		// 输出: "不匹配: 实际=hello, 期望=world"
		// 
		public static void ErrorIfNotEqual(string actual, string expected,
			string desc="Expected {1}, got {0}") {
			// 【== 运算符对于字符串的特殊行为】
			// 在C#中,对字符串使用 == 会比较内容而不是引用
			// 这是因为string类型重载了 == 运算符
			if (actual == expected) return;  // 如果相等,直接返回(测试通过)
			
			// 【string.Format详解】
			// Format方法创建格式化字符串
			// 参数1: 格式模板字符串
			// 参数2+: 要插入模板的值(按索引{0},{1}...对应)
			ReportError(string.Format(desc, actual, expected));
		}

		// ====================================================================
		// 【方法6】ErrorIfNotEqual (浮点数重载版本)
		// ====================================================================
		// 
		// 【功能描述】
		// 比较两个浮点数是否相等。如果不相等,则测试失败。
		// 
		// 【参数说明】
		// actual: 实际得到的浮点数值
		// expected: 期望的浮点数值
		// desc: 可选参数,自定义错误描述模板
		// 
		// 【方法重载说明】(高级C#特性)
		// 这个方法与上面的ErrorIfNotEqual同名,但参数类型不同
		// 这称为"方法重载"(Method Overloading)
		// C#会根据传入参数的类型自动选择正确的方法版本
		// 
		// 【潜在问题警告】
		// 直接使用 == 比较浮点数可能不准确,因为浮点数存在精度问题
		// 更好的做法是使用容差比较,如: Math.Abs(actual - expected) < 0.0001
		// 但这里为了简单,直接使用了 ==
		// 
		// 【使用示例】
		// ErrorIfNotEqual(3.14f, 3.14f);  // 测试通过
		// ErrorIfNotEqual(3.14f, 3.15f);  // 测试失败,输出错误
		// 
		public static void ErrorIfNotEqual(float actual, float expected,
			string desc="Expected {1}, got {0}") {
			if (actual == expected) return;  // 相等则返回
			
			// 【装箱说明】(高级概念)
			// float是值类型,string.Format需要object类型参数
			// 这里会发生"装箱"(Boxing): 将值类型转换为引用类型
			// 这是C#自动完成的,但会有轻微的性能开销
			ReportError(string.Format(desc, actual, expected));
		}

		// ====================================================================
		// 【方法7】Run - 测试套件入口方法
		// ====================================================================
		// 
		// 【功能描述】
		// 这是运行所有单元测试的主入口方法。
		// 它负责调用各个模块的测试方法。
		// 
		// 【当前实现】
		// 目前调用了两个模块的测试:
		// 1. Lexer.RunUnitTests() - 词法分析器测试
		// 2. Parser.RunUnitTests() - 语法分析器测试
		// 
		// 【扩展性】
		// 随着项目发展,可以在这里添加更多模块的测试调用
		// 例如: Interpreter.RunUnitTests(), etc.
		// 
		// 【Lexer和Parser说明】
		// 这两个类应该在项目的其他文件中定义
		// Lexer: 词法分析器,负责将源代码分解为标记(tokens)
		// Parser: 语法分析器,负责将标记组织成语法树
		// 
		// 【调用方式】
		// 从程序的任何地方调用: Miniscript.UnitTest.Run();
		// 
		public static void Run() {
			// 运行词法分析器的单元测试
			// Lexer是MiniScript的词法分析组件
			Lexer.RunUnitTests();
			
			// 运行语法分析器的单元测试
			// Parser是MiniScript的语法分析组件
			Parser.RunUnitTests();
		}
	}
}

// ============================================================================
// 【文件总结】
// ============================================================================
//
// 【整体架构分析】
// 这个文件实现了一个轻量级的单元测试框架,专门为MiniScript项目设计。
// 它不依赖于外部测试框架(如NUnit、xUnit),而是提供了一套简单直接的
// 测试工具方法。
//
// 【核心设计思想】
// 1. 简单性: 只提供最基本但最常用的断言方法
// 2. 集中性: 所有错误都通过ReportError统一处理
// 3. 可扩展性: 易于添加新的断言方法和测试模块
// 4. 跨平台: 同时支持标准.NET和Unity环境
//
// 【方法总览与分类】
// 
// 错误报告层:
//   - ReportError: 核心错误报告方法
//
// 基础断言层:
//   - ErrorIf: 通用条件断言
//
// 空值检查层:
//   - ErrorIfNull: 检查不应为null的对象
//   - ErrorIfNotNull: 检查应该为null的对象
//
// 相等性检查层:
//   - ErrorIfNotEqual(string): 字符串比较
//   - ErrorIfNotEqual(float): 浮点数比较
//
// 测试执行层:
//   - Run: 测试套件入口
//
// 【涉及的C#高级特性】
//
// 1. 静态类和静态方法
//    - 不需要实例化,直接通过类名调用
//    - 适合工具类和辅助类
//
// 2. 方法重载 (Method Overloading)
//    - ErrorIfNotEqual有两个版本(string和float)
//    - 编译器根据参数类型自动选择
//
// 3. 可选参数 (Optional Parameters)
//    - desc参数有默认值
//    - 调用时可以省略该参数
//
// 4. 条件编译 (#if directive)
//    - 根据编译符号包含或排除代码
//    - 用于跨平台支持
//
// 5. 字符串格式化 (string.Format)
//    - 使用占位符{0},{1}...格式化字符串
//    - 类似于C语言的printf
//
// 6. 装箱 (Boxing)
//    - 值类型(如float)转换为object类型
//    - 在string.Format调用时自动发生
//
// 【使用模式建议】
//
// 在其他测试类中使用这些方法的典型模式:
//
// public static void TestSomething() {
//     // 准备测试数据
//     var result = FunctionToTest();
//     
//     // 使用断言验证结果
//     UnitTest.ErrorIfNull(result);
//     UnitTest.ErrorIfNotEqual(result.Property, "expected value");
// }
//
// 【潜在改进方向】
//
// 1. 添加更多断言方法:
//    - ErrorIfNotEqual的泛型版本
//    - 浮点数容差比较
//    - 集合比较方法
//
// 2. 添加测试统计:
//    - 记录运行的测试数量
//    - 记录失败的测试数量
//    - 输出测试报告
//
// 3. 异常处理:
//    - 捕获并报告测试中的异常
//    - 允许测试在某个失败后继续执行
//
// 4. 性能测试支持:
//    - 添加计时功能
//    - 测试性能基准
//
// 【学习要点】
//
// 对于C#初学者,这个文件是很好的学习材料:
// - 展示了如何设计简洁的API
// - 演示了静态类的实际应用
// - 说明了方法重载的用途
// - 展示了跨平台代码的编写方式
//
// ============================================================================