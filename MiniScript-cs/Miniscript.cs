/*
 * ============================================================================
 * 文件概要说明
 * ============================================================================
 * 文件名: Miniscript.cs
 * 命名空间: Miniscript
 * 
 * 功能描述:
 * 这是MiniScript解释器的核心基础文件,定义了两个主要的公共类:
 * 
 * 1. Error类 - 错误处理类
 *    - 用于表示脚本编译和执行过程中的错误信息
 *    - 包含错误行号、错误类型、错误描述等信息
 *    - 提供了错误断言的静态方法
 * 
 * 2. Script类 - 脚本类
 *    - 代表一个MiniScript脚本对象
 *    - 负责脚本的编译工作
 *    - 维护编译过程中产生的错误列表
 * 
 * 设计模式:
 * - 使用了枚举(Enum)来定义错误类型,便于扩展和类型安全
 * - 采用了错误收集机制,将所有错误存储在列表中而非立即抛出异常
 * 
 * 依赖关系:
 * - System命名空间: 提供基础类型如Console等
 * - System.Collections.Generic命名空间: 提供泛型集合List<T>
 * 
 * 阅读建议:
 * 1. 先理解Error类的结构和用途
 * 2. 再了解Script类如何使用Error类
 * 3. 注意观察类的访问修饰符(public/private)
 * ============================================================================
 */

using System;                           // 引入System命名空间,提供基础类型和Console等常用类
using System.Collections.Generic;       // 引入泛型集合命名空间,主要使用List<T>泛型列表

namespace Miniscript {
	/*
	 * ========================================================================
	 * Error类 - 错误信息类
	 * ========================================================================
	 * 作用: 封装脚本处理过程中的错误信息
	 * 
	 * 设计要点:
	 * - 使用public访问修饰符,表示这个类可以被外部访问
	 * - 包含嵌套枚举Type来定义错误类型
	 * - 存储错误的位置(行号)、类型和描述信息
	 * 
	 * 使用场景:
	 * - 编译时语法错误
	 * - 运行时错误(目前枚举中只定义了Syntax,但可扩展)
	 * ========================================================================
	 */
	public class Error {
		/*
		 * ====================================================================
		 * Type枚举 - 错误类型枚举
		 * ====================================================================
		 * 说明:
		 * - 这是一个嵌套在Error类内部的枚举类型
		 * - 使用public修饰符,可以通过Error.Type来访问
		 * - 枚举是值类型,用于定义一组命名的整数常量
		 * 
		 * C#知识点 - 枚举(Enum):
		 * - 枚举是一种值类型,默认情况下第一个成员值为0,后续递增
		 * - 可以使用Error.Type.Syntax来引用枚举成员
		 * - 枚举提供了类型安全,避免使用魔法数字
		 * 
		 * 当前定义:
		 * - Syntax: 语法错误类型(值为0)
		 * 
		 * 扩展性:
		 * 未来可以添加更多错误类型,例如:
		 * - Runtime: 运行时错误
		 * - Type: 类型错误
		 * - Reference: 引用错误等
		 * ====================================================================
		 */
		public enum Type {
			Syntax    // 语法错误 - 表示脚本源代码不符合MiniScript语法规则
		}

		/*
		 * ====================================================================
		 * 成员字段 - 存储错误的详细信息
		 * ====================================================================
		 */
		
		public int lineNum;          // 错误发生的行号 - 用于定位错误在源代码中的位置
		                             // 使用int类型存储行号,从某个起始值开始(通常是1)
		
		public Type type;            // 错误类型 - 使用上面定义的Type枚举
		                             // 表示这是什么类别的错误(当前只有Syntax)
		
		public string description;   // 错误描述信息 - 人类可读的错误说明文本
		                             // 使用string类型存储详细的错误描述

		/*
		 * ====================================================================
		 * Error构造函数 - 创建错误对象
		 * ====================================================================
		 * 参数说明:
		 * @param lineNum - 错误所在的行号
		 * @param type - 错误的类型(使用Type枚举)
		 * @param description - 可选的错误描述,默认为null
		 * 
		 * C#知识点 - 可选参数:
		 * - description=null 表示这是一个可选参数
		 * - 调用时可以省略此参数: new Error(10, Type.Syntax)
		 * - 也可以提供此参数: new Error(10, Type.Syntax, "缺少分号")
		 * 
		 * 功能逻辑:
		 * 1. 使用this关键字区分成员变量和参数
		 * 2. 如果未提供description,则使用type.ToString()作为默认描述
		 * 3. 如果提供了description,则使用提供的描述
		 * 
		 * C#知识点 - this关键字:
		 * - this.lineNum 指的是类的成员变量
		 * - lineNum 指的是构造函数的参数
		 * - 使用this可以明确区分两者,避免歧义
		 * 
		 * C#知识点 - ToString()方法:
		 * - 每个C#对象都有ToString()方法(继承自Object类)
		 * - 枚举类型的ToString()会返回枚举成员的名称字符串
		 * - 例如: Type.Syntax.ToString() 返回 "Syntax"
		 * ====================================================================
		 */
		public Error(int lineNum, Type type, string description=null) {
			this.lineNum = lineNum;        // 保存错误行号到成员变量
			this.type = type;              // 保存错误类型到成员变量
			
			// 条件判断:如果没有提供描述信息
			if (description == null) {
				// 使用枚举的ToString()方法生成默认描述
				// 例如:如果type是Type.Syntax,这里会得到"Syntax"字符串
				this.description = type.ToString();
			} else {
				// 使用调用者提供的自定义描述信息
				this.description = description;
			}
		}

		/*
		 * ====================================================================
		 * Assert静态方法 - 断言检查
		 * ====================================================================
		 * 参数说明:
		 * @param condition - 要检查的条件表达式(布尔值)
		 * 
		 * C#知识点 - static关键字:
		 * - static表示这是一个静态方法
		 * - 静态方法属于类本身,而非类的实例
		 * - 调用方式: Error.Assert(someCondition) 而不需要创建Error对象
		 * - 静态方法内部不能访问非静态成员(因为没有this实例)
		 * 
		 * 功能说明:
		 * - 这是一个简单的断言方法,用于调试和验证程序内部状态
		 * - 当传入的条件为false时,会在控制台输出错误信息
		 * 
		 * 使用场景示例:
		 * Error.Assert(list != null);  // 确保列表不为空
		 * Error.Assert(index >= 0);    // 确保索引非负
		 * 
		 * 注意事项:
		 * - 这个实现比较简单,只是打印信息,并不会中断程序执行
		 * - 生产环境中的断言通常会抛出异常或记录日志
		 * - C#标准库中有System.Diagnostics.Debug.Assert提供更完善的断言功能
		 * 
		 * C#知识点 - Console.WriteLine:
		 * - Console是System命名空间中的静态类
		 * - WriteLine是Console的静态方法,用于向控制台输出一行文本
		 * - 这是C#中最基本的输出调试信息的方式
		 * ====================================================================
		 */
		public static void Assert(bool condition) {
			// 如果条件不满足(即condition为false)
			if (!condition) {
				// 向控制台输出断言失败的信息
				// 这有助于开发者发现程序内部的逻辑错误
				Console.WriteLine("Internal assertion failed.");
				// 注意:这里只是打印信息,程序会继续执行
				// 更严格的实现可能会抛出异常或终止程序
			}
		}
	}

	/*
	 * ========================================================================
	 * Script类 - 脚本类
	 * ========================================================================
	 * 作用: 表示一个MiniScript脚本,负责脚本的编译和执行
	 * 
	 * 设计要点:
	 * - 使用public访问修饰符,可以被外部代码使用
	 * - 维护一个错误列表,收集编译过程中的所有错误
	 * - 提供Compile方法用于编译源代码
	 * 
	 * 使用流程:
	 * 1. 创建Script对象: Script script = new Script();
	 * 2. 编译源代码: script.Compile(sourceCode);
	 * 3. 检查错误: if (script.errors.Count > 0) { ... }
	 * 
	 * 设计理念:
	 * - 采用"收集错误"而非"立即失败"的策略
	 * - 这样可以一次性报告所有错误,提升用户体验
	 * ========================================================================
	 */
	public class Script {
		/*
		 * ====================================================================
		 * errors成员 - 错误列表
		 * ====================================================================
		 * C#知识点 - 泛型List<T>:
		 * - List<T>是.NET中最常用的动态数组集合类
		 * - T是类型参数,这里T=Error,所以List<Error>存储Error对象
		 * - List<T>定义在System.Collections.Generic命名空间中
		 * 
		 * List<T>的主要特点:
		 * - 动态大小:可以随时添加或删除元素,自动扩容
		 * - 类型安全:只能存储Error类型的对象
		 * - 索引访问:可以通过errors[0]访问元素
		 * 
		 * 常用方法和属性:
		 * - Add(item): 添加元素
		 * - Count: 获取元素数量
		 * - Clear(): 清空列表
		 * - Remove(item): 移除指定元素
		 * - Contains(item): 检查是否包含某元素
		 * 
		 * 使用示例:
		 * errors.Add(new Error(10, Error.Type.Syntax, "语法错误"));
		 * int errorCount = errors.Count;
		 * Error firstError = errors[0];
		 * 
		 * 为什么使用List而不是数组:
		 * - 编译时无法确定会有多少个错误
		 * - List可以动态增长,使用更方便
		 * - 数组大小固定,需要预先指定或手动扩容
		 * ====================================================================
		 */
		public List<Error> errors;   // 存储编译和执行过程中遇到的所有错误
		                             // 初始时为null,需要在使用前初始化

		/*
		 * ====================================================================
		 * Compile方法 - 编译源代码
		 * ====================================================================
		 * 参数说明:
		 * @param source - 要编译的MiniScript源代码字符串
		 * 
		 * 功能说明:
		 * - 这个方法负责将MiniScript源代码编译成可执行的形式
		 * - 当前实现为空,实际的编译逻辑需要在此添加
		 * 
		 * 典型的编译流程应包括:
		 * 1. 词法分析(Lexical Analysis):
		 *    - 将源代码分解成标记(tokens)
		 *    - 例如:识别关键字、标识符、运算符、字面量等
		 * 
		 * 2. 语法分析(Syntax Analysis):
		 *    - 检查标记序列是否符合语法规则
		 *    - 构建抽象语法树(AST)
		 *    - 发现的语法错误会添加到errors列表
		 * 
		 * 3. 语义分析(Semantic Analysis):
		 *    - 检查类型匹配
		 *    - 检查变量是否声明
		 *    - 检查函数调用是否正确等
		 * 
		 * 4. 代码生成(Code Generation):
		 *    - 生成中间代码或字节码
		 *    - 为解释器执行做准备
		 * 
		 * 错误处理策略:
		 * - 遇到错误时不应立即中断编译
		 * - 应该创建Error对象并添加到errors列表
		 * - 尽可能继续编译,找出更多错误
		 * 
		 * 实现示例(伪代码):
		 * public void Compile(string source) {
		 *     errors = new List<Error>();  // 初始化错误列表
		 *     
		 *     try {
		 *         // 执行词法分析
		 *         var tokens = Tokenize(source);
		 *         
		 *         // 执行语法分析
		 *         var ast = Parse(tokens);
		 *         
		 *         // 如果没有错误,生成代码
		 *         if (errors.Count == 0) {
		 *             GenerateCode(ast);
		 *         }
		 *     } catch (Exception ex) {
		 *         // 捕获未预期的异常
		 *         errors.Add(new Error(0, Error.Type.Syntax, ex.Message));
		 *     }
		 * }
		 * 
		 * 返回值说明:
		 * - 方法返回类型为void,表示无返回值
		 * - 编译结果通过errors列表来传达
		 * - 调用者需要检查errors.Count来判断编译是否成功
		 * ====================================================================
		 */
		public void Compile(string source) {
			// 方法体为空 - 这是一个待实现的方法
			// 实际项目中,这里应该包含完整的编译逻辑
			// 
			// 提示:在实现时,应该:
			// 1. 首先初始化errors列表: errors = new List<Error>();
			// 2. 对source进行词法分析和语法分析
			// 3. 遇到错误时创建Error对象并添加到errors列表
			// 4. 如果没有错误,生成可执行的代码或字节码
		}
	}

}

/*
 * ============================================================================
 * 文件总结说明
 * ============================================================================
 * 
 * 一、整体架构总结
 * ----------------
 * 这个文件是MiniScript解释器的基础框架,定义了两个核心类:
 * 
 * 1. Error类:错误信息的数据结构
 *    - 封装了错误的三个关键属性:位置(lineNum)、类型(type)、描述(description)
 *    - 提供了灵活的构造方式,支持自定义描述或使用默认描述
 *    - 包含静态断言方法,用于内部调试
 * 
 * 2. Script类:脚本处理的主类
 *    - 负责脚本的编译工作
 *    - 维护错误列表,采用"收集所有错误"的策略
 *    - 当前只有框架,实际编译逻辑待实现
 * 
 * 二、涉及的C#高级特性详解
 * -------------------------
 * 
 * 1. 枚举(Enum)
 *    位置: Error.Type
 *    作用: 定义一组命名的整数常量,提供类型安全
 *    优点: 
 *    - 代码可读性强:Error.Type.Syntax比数字1更清晰
 *    - 编译时检查:不能赋予非法值
 *    - 易于扩展:添加新错误类型只需添加枚举成员
 * 
 * 2. 可选参数(Optional Parameters)
 *    位置: Error构造函数的description参数
 *    语法: string description=null
 *    特点:
 *    - 调用时可以省略该参数
 *    - 默认值在编译时确定
 *    - 可选参数必须放在必选参数之后
 * 
 * 3. 泛型集合(Generic Collections)
 *    位置: List<Error> errors
 *    详解:
 *    - List<T>是泛型类,T是类型参数
 *    - List<Error>表示"Error类型的列表"
 *    - 优于非泛型ArrayList:类型安全,无需类型转换,性能更好
 *    常用操作:
 *    ```csharp
 *    errors = new List<Error>();              // 创建空列表
 *    errors.Add(new Error(1, Type.Syntax));   // 添加元素
 *    int count = errors.Count;                // 获取元素数量
 *    Error first = errors[0];                 // 索引访问
 *    errors.Clear();                          // 清空列表
 *    foreach (Error err in errors) { ... }    // 遍历
 *    ```
 * 
 * 4. 静态成员(Static Members)
 *    位置: Error.Assert方法
 *    特点:
 *    - 属于类本身,不属于任何实例
 *    - 无需创建对象即可调用:Error.Assert(condition)
 *    - 静态方法不能访问实例成员(没有this)
 *    - 常用于工具方法、工厂方法等
 * 
 * 5. 访问修饰符(Access Modifiers)
 *    本文件中使用的修饰符:
 *    - public: 所有类、方法、字段都是公开的,可以被任何代码访问
 *    其他常见修饰符(本文件未使用):
 *    - private: 只能在类内部访问
 *    - protected: 可以在类及其子类中访问
 *    - internal: 只能在同一程序集内访问
 * 
 * 三、设计模式和编程思想
 * ---------------------
 * 
 * 1. 错误收集模式
 *    - 不是遇到第一个错误就停止,而是继续处理并收集所有错误
 *    - 优点:用户可以一次性看到所有问题,提高效率
 *    - 实现:使用List<Error>存储所有错误
 * 
 * 2. 关注点分离
 *    - Error类专注于错误信息的表示
 *    - Script类专注于脚本的处理
 *    - 职责清晰,便于维护和扩展
 * 
 * 3. 防御性编程
 *    - Assert方法用于检查内部状态
 *    - 可选参数提供默认值,避免null相关错误
 * 
 * 四、使用示例
 * -----------
 * 
 * ```csharp
 * // 创建并使用Script对象
 * Script script = new Script();
 * 
 * // 编译一段MiniScript代码
 * string sourceCode = "print \"Hello, World!\"";
 * script.Compile(sourceCode);
 * 
 * // 检查是否有错误
 * if (script.errors != null && script.errors.Count > 0) {
 *     Console.WriteLine($"编译失败,发现 {script.errors.Count} 个错误:");
 *     foreach (Error err in script.errors) {
 *         Console.WriteLine($"  行 {err.lineNum}: {err.description}");
 *     }
 * } else {
 *     Console.WriteLine("编译成功!");
 * }
 * 
 * // 手动创建错误对象
 * Error error1 = new Error(10, Error.Type.Syntax);  // 使用默认描述
 * Error error2 = new Error(15, Error.Type.Syntax, "缺少右括号");  // 自定义描述
 * 
 * // 使用断言
 * Error.Assert(script != null);  // 检查对象不为null
 * ```
 * 
 * 五、后续开发建议
 * ---------------
 * 
 * 1. 扩展错误类型
 *    在Error.Type枚举中添加更多错误类型:
 *    ```csharp
 *    public enum Type {
 *        Syntax,      // 语法错误
 *        Runtime,     // 运行时错误
 *        Type,        // 类型错误
 *        Reference,   // 引用错误
 *        Overflow     // 溢出错误
 *    }
 *    ```
 * 
 * 2. 实现Compile方法
 *    添加完整的编译逻辑:
 *    - 词法分析器(Lexer)
 *    - 语法分析器(Parser)
 *    - 代码生成器(CodeGenerator)
 * 
 * 3. 增强Error类
 *    - 添加列号信息(column number)
 *    - 添加源代码片段,方便定位
 *    - 重写ToString()方法,提供格式化输出
 * 
 * 4. 添加日志功能
 *    - 将断言信息记录到日志文件
 *    - 添加不同级别的日志(Debug, Info, Warning, Error)
 * 
 * 5. 异常处理
 *    - 在关键位置添加try-catch块
 *    - 将捕获的异常转换为Error对象
 * 
 * 六、学习要点
 * -----------
 * 
 * 对于C#初学者,通过这个文件应该掌握:
 * 
 * 1. 基础概念:
 *    - 类和对象的关系
 *    - 构造函数的作用
 *    - 成员变量和方法
 * 
 * 2. 重要特性:
 *    - 枚举的定义和使用
 *    - 泛型集合List<T>
 *    - 静态成员与实例成员的区别
 *    - 可选参数的使用
 * 
 * 3. 编程思想:
 *    - 封装:将相关数据和方法组织在类中
 *    - 错误处理:收集错误而非立即失败
 *    - 职责分离:每个类有明确的职责
 * 
 * 4. 实践技巧:
 *    - 使用this关键字区分成员和参数
 *    - 使用枚举提高代码可读性
 *    - 使用泛型集合管理对象列表
 *    - 使用静态方法实现工具函数
 * 
 * ============================================================================
 * 总结:这是一个设计良好的基础框架,虽然代码量不大,但展示了C#编程的多个
 * 重要概念。理解这个文件是深入学习MiniScript解释器的第一步。
 * ============================================================================
 */