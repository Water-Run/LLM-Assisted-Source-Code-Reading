/*
** $Id: ldebug.h $
** Auxiliary functions from Debug Interface module
** 调试接口模块的辅助函数
** See Copyright Notice in lua.h
** 参见 lua.h 中的版权声明
*/

/*
================================================================================
文件概要：ldebug.h - Lua 调试接口头文件
================================================================================

【文件基本信息】
- 文件名：ldebug.h
- 所属模块：Lua 调试接口模块（Debug Interface Module）
- 文件类型：C语言头文件
- 作用：声明调试相关的辅助函数和宏定义

【主要功能】
1. 提供调试信息获取功能
   - 获取函数行号信息
   - 查找局部变量
   - 追踪函数调用和执行

2. 错误报告机制
   - 类型错误报告（typeerror）
   - 调用错误报告（callerror）
   - 运行时错误报告（runerror）
   - 各种操作错误报告

3. Hook（钩子）机制支持
   - 提供重置hook计数器的宏

4. 行号信息管理
   - 定义绝对行号信息的标记
   - 管理指令与源代码行号的对应关系

【核心概念】
- CallInfo（ci）：调用信息结构，记录函数调用状态
- Proto：函数原型，包含函数的字节码和调试信息
- TValue：Lua值的通用表示
- PC（Program Counter）：程序计数器，指向当前执行的指令

【使用场景】
- Lua虚拟机执行过程中的调试信息收集
- 错误发生时生成详细的错误消息
- 实现Lua的debug库功能
- 支持IDE调试器接入

================================================================================
*/

#ifndef ldebug_h
#define ldebug_h

#include "lstate.h" /* 包含Lua状态机相关定义 */

/*
--------------------------------------------------------------------------------
宏定义：pcRel - 计算相对PC值
--------------------------------------------------------------------------------
【功能说明】
计算程序计数器（PC）相对于函数代码起始位置的偏移量

【参数说明】
- pc: 当前程序计数器指针（指向Instruction的指针）
- p:  函数原型指针（Proto*），包含code数组

【返回值】
返回相对偏移量（从0开始），-1表示函数入口前

【实现细节】
1. (pc) - (p)->code：计算指针差值，得到当前指令在code数组中的索引
2. cast_int(...)：将结果转换为int类型
3. 减1：调整为相对偏移（因为PC通常指向下一条要执行的指令）

【使用示例】
如果函数的code数组起始地址是0x1000，当前PC是0x1010
假设每条指令4字节，则：
- (0x1010 - 0x1000) / 4 = 4（第5条指令）
- 减1后得到3（表示刚执行完第4条指令）
--------------------------------------------------------------------------------
*/
#define pcRel(pc, p) (cast_int((pc) - (p)->code) - 1)

/*
--------------------------------------------------------------------------------
宏定义：ci_func - 获取活动Lua函数
--------------------------------------------------------------------------------
【功能说明】
从CallInfo结构中提取当前正在执行的Lua闭包（函数）

【参数说明】
- ci: CallInfo指针，表示一个函数调用信息

【返回值】
返回LClosure*类型，即Lua闭包指针

【实现细节分层解析】
1. (ci)->func.p
   - ci->func是一个StkId（栈索引），指向栈上存储函数对象的位置
   - .p表示访问该位置的指针

2. s2v(...)
   - s2v = "stack to value"（栈到值）
   - 将栈上的位置转换为TValue*（Lua值指针）
   - TValue是Lua中所有值的统一表示结构

3. clLvalue(...)
   - cl = "closure"（闭包）
   - Lvalue = "Lua value"
   - 从TValue中提取Lua闭包（LClosure*）
   - 这是一个类型转换和提取操作

【使用场景】
- 获取当前执行函数，用于调试信息
- 错误报告时需要知道错误发生在哪个函数
- Hook回调时传递函数信息
--------------------------------------------------------------------------------
*/
#define ci_func(ci) (clLvalue(s2v((ci)->func.p)))

/*
--------------------------------------------------------------------------------
宏定义：resethookcount - 重置Hook计数器
--------------------------------------------------------------------------------
【功能说明】
将Hook计数器重置为基础值，用于控制Hook触发频率

【参数说明】
- L: lua_State*，Lua状态机指针

【实现细节】
1. L->hookcount：当前Hook计数器
   - 每执行一定数量的指令会递减
   - 减到0时触发Hook

2. L->basehookcount：基础Hook计数值
   - 用户设定的Hook触发间隔
   - 每次触发后，hookcount重置为这个值

【Hook机制说明】
Lua的Hook是调试机制，可以在以下时机触发：
- LUA_MASKCALL：函数调用时
- LUA_MASKRET：函数返回时
- LUA_MASKLINE：执行到新的源代码行时
- LUA_MASKCOUNT：执行指定数量的指令后

【使用场景】
- 在Hook回调处理完后重置计数器
- 修改Hook参数后重新初始化计数器
- 确保Hook按预期频率触发
--------------------------------------------------------------------------------
*/
#define resethookcount(L) (L->hookcount = L->basehookcount)

/*
--------------------------------------------------------------------------------
常量定义：ABSLINEINFO - 绝对行号信息标记
--------------------------------------------------------------------------------
【功能说明】
在lineinfo数组中标记某个位置在abslineinfo数组中有对应的绝对行号信息

【值说明】
-0x80 = -128（二进制：10000000）

【Lua行号信息存储机制】
Lua使用两个数组存储源代码行号信息：

1. lineinfo数组（相对行号）
   - 存储每条指令相对于前一条指令的行号变化
   - 使用小整数，节省空间
   - 如果某位置的值是ABSLINEINFO，表示需要查找绝对行号

2. abslineinfo数组（绝对行号）
   - 定期存储绝对行号信息
   - 作为"锚点"，防止累计误差
   - 可以快速定位到准确的行号

【为什么使用-0x80】
1. 负数可以与正常的行号增量区分
2. -128在char类型中可以表示（char范围：-128到127）
3. 易于识别的特殊值

【示例】
假设源代码：
  行1: function foo()
  行2:   local x = 1
  行5:   print(x)
  行6: end

lineinfo可能存储为：[1, 1, ABSLINEINFO, 1]
abslineinfo存储为：[{pc=2, line=5}]
--------------------------------------------------------------------------------
*/
#define ABSLINEINFO (-0x80)

/*
--------------------------------------------------------------------------------
常量定义：MAXIWTHABS - 最大连续指令数（无绝对行号）
--------------------------------------------------------------------------------
【功能说明】
定义在abslineinfo中插入绝对行号信息的最大间隔

【默认值】
128条指令

【设计考虑】
1. 为什么是2的幂（128 = 2^7）
   - 可以使用位运算快速计算除法和取模
   - 例如：pc / 128 可以优化为 pc >> 7
   - 例如：pc % 128 可以优化为 pc & 0x7F

2. 为什么选择128
   - 平衡内存占用和查找速度
   - 太小：abslineinfo数组占用更多内存
   -太大：查找行号时需要累加更多lineinfo

【查找行号算法】
假设要查找PC=200的指令对应的行号：
1. 找到最近的绝对行号锚点：200 / 128 = 1（第2个锚点）
2. 从锚点开始累加lineinfo的增量
3. 最多需要累加128个值

【可配置性】
通过编译时定义MAXIWTHABS可以调整这个值：
  gcc -DMAXIWTHABS=256 ...
--------------------------------------------------------------------------------
*/
#if !defined(MAXIWTHABS)
#define MAXIWTHABS 128
#endif

/*
================================================================================
函数声明部分
================================================================================
以下是调试模块提供的公共API函数声明
所有函数都使用LUAI_FUNC宏标记，表示这是Lua内部API函数
--------------------------------------------------------------------------------
*/

/*
--------------------------------------------------------------------------------
函数：luaG_getfuncline - 获取函数指定PC的源代码行号
--------------------------------------------------------------------------------
【函数原型】
int luaG_getfuncline (const Proto *f, int pc)

【参数说明】
- f:  函数原型（const Proto*），包含字节码和调试信息
- pc: 程序计数器值，指令索引

【返回值】
返回对应的源代码行号，如果无法确定则返回-1

【功能详解】
1. 从函数的调试信息中查找PC对应的源代码行号
2. 使用lineinfo和abslineinfo数组进行查找
3. 处理相对行号和绝对行号的转换

【算法流程】
1. 检查PC是否在有效范围内
2. 找到最近的abslineinfo锚点
3. 从锚点开始累加lineinfo的增量
4. 返回最终行号

【使用场景】
- 错误报告时显示错误发生的行号
- 调试器显示当前执行位置
- 生成调用栈追踪信息
--------------------------------------------------------------------------------
*/
LUAI_FUNC int luaG_getfuncline(const Proto *f, int pc);

/*
--------------------------------------------------------------------------------
函数：luaG_findlocal - 查找局部变量
--------------------------------------------------------------------------------
【函数原型】
const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos)

【参数说明】
- L:   Lua状态机指针
- ci:  调用信息指针，表示要查询的函数调用
- n:   局部变量索引（从1开始）
- pos: 输出参数，返回变量在栈上的位置（StkId*）

【返回值】
- 成功：返回局部变量名（const char*）
- 失败：返回NULL（变量不存在或索引超出范围）

【功能详解】
1. 在指定的函数调用中查找第n个局部变量
2. 考虑变量的作用域（某些局部变量可能已经超出作用域）
3. 通过pos参数返回变量在栈上的具体位置

【局部变量编号规则】
- n=1: 第一个局部变量
- n=2: 第二个局部变量
- ...
- 包括函数参数和局部变量
- 不包括临时变量（temporary values）

【使用场景】
- debug.getlocal() 函数的实现
- 调试器显示局部变量
- 错误报告时显示相关变量
--------------------------------------------------------------------------------
*/
LUAI_FUNC const char *luaG_findlocal(lua_State *L, CallInfo *ci, int n,
                                     StkId *pos);

/*
--------------------------------------------------------------------------------
函数：luaG_typeerror - 类型错误报告
--------------------------------------------------------------------------------
【函数原型】
l_noret luaG_typeerror (lua_State *L, const TValue *o, const char *opname)

【参数说明】
- L:      Lua状态机指针
- o:      导致错误的值（TValue*）
- opname: 操作名称字符串

【返回值】
l_noret 表示函数不会返回（会抛出错误）

【功能详解】
生成类型错误消息并抛出错误，格式类似：
"attempt to [opname] a [typename] value"
例如："attempt to call a number value"

【l_noret说明】
这是一个特殊的返回类型标记：
- 在某些编译器中定义为 __attribute__((noreturn))
- 告诉编译器此函数不会正常返回
- 允许编译器进行优化，不生成返回后的代码
- 调用此函数后，程序流程会通过longjmp跳转

【使用场景】
- 尝试调用非函数类型时
- 尝试对非数字进行算术运算
- 尝试索引非表类型
--------------------------------------------------------------------------------
*/
LUAI_FUNC l_noret luaG_typeerror(lua_State *L, const TValue *o,
                                 const char *opname);

/*
--------------------------------------------------------------------------------
函数：luaG_callerror - 调用错误报告
--------------------------------------------------------------------------------
【函数原型】
l_noret luaG_callerror (lua_State *L, const TValue *o)

【参数说明】
- L: Lua状态机指针
- o: 尝试调用的值（TValue*）

【返回值】
不返回（l_noret）

【功能详解】
生成更详细的调用错误消息，可能包含：
- 对象的实际类型
- 是否有__call元方法但调用失败
- 可能的修正建议

【与luaG_typeerror的区别】
- luaG_typeerror：通用类型错误
- luaG_callerror：专门针对调用操作的错误，提供更具体的信息

【使用场景】
- 尝试调用nil、number、string等不可调用类型
- 调用表但__call元方法不存在或无效
--------------------------------------------------------------------------------
*/
LUAI_FUNC l_noret luaG_callerror(lua_State *L, const TValue *o);

/*
--------------------------------------------------------------------------------
函数：luaG_forerror - for循环错误报告
--------------------------------------------------------------------------------
【函数原型】
l_noret luaG_forerror (lua_State *L, const TValue *o, const char *what)

【参数说明】
- L:    Lua状态机指针
- o:    导致错误的值（TValue*）
- what: 描述是哪个部分的错误（字符串）

【返回值】
不返回（l_noret）

【功能详解】
处理for循环相关的错误，包括：
1. 数值for循环（numeric for）
   - 初始值、限制值、步长必须是数字
2. 泛型for循环（generic for）
   - 迭代器必须是函数

【what参数说明】
- "initial value"：初始值错误
- "limit"：限制值错误
- "step"：步长错误
- "iterator"：迭代器错误

【使用场景】
例如：for i = "a", 10 do ... end
会产生错误："'for' initial value must be a number"
--------------------------------------------------------------------------------
*/
LUAI_FUNC l_noret luaG_forerror(lua_State *L, const TValue *o,
                                const char *what);

/*
--------------------------------------------------------------------------------
函数：luaG_concaterror - 连接操作错误报告
--------------------------------------------------------------------------------
【函数原型】
l_noret luaG_concaterror (lua_State *L, const TValue *p1, const TValue *p2)

【参数说明】
- L:  Lua状态机指针
- p1: 第一个操作数（TValue*）
- p2: 第二个操作数（TValue*）

【返回值】
不返回（l_noret）

【功能详解】
处理字符串连接操作(..)的错误
Lua只允许字符串和数字进行连接操作

【错误示例】
1. "hello" .. {}     -- 尝试连接表
2. "hello" .. nil    -- 尝试连接nil
3. true .. "world"   -- 尝试连接布尔值

【错误消息格式】
会指出哪个操作数导致了错误，例如：
"attempt to concatenate a table value"

【使用场景】
- 字节码OP_CONCAT执行时的类型检查
- 确保只有字符串和数字参与连接
--------------------------------------------------------------------------------
*/
LUAI_FUNC l_noret luaG_concaterror(lua_State *L, const TValue *p1,
                                   const TValue *p2);

/*
--------------------------------------------------------------------------------
函数：luaG_opinterror - 操作数错误报告（通用）
--------------------------------------------------------------------------------
【函数原型】
l_noret luaG_opinterror (lua_State *L, const TValue *p1,
                         const TValue *p2, const char *msg)

【参数说明】
- L:   Lua状态机指针
- p1:  第一个操作数（TValue*）
- p2:  第二个操作数（TValue*）
- msg: 错误消息模板

【返回值】
不返回（l_noret）

【功能详解】
通用的二元操作错误报告函数
检查两个操作数，找出导致错误的那个，生成详细错误消息

【检查顺序】
1. 首先检查p1是否是合法类型
2. 如果p1合法，则p2是问题所在
3. 在错误消息中指明具体的操作数

【使用场景】
- 算术运算错误（+, -, *, /, %等）
- 位运算错误（&, |, ^, <<, >>等）
- 比较运算错误（部分情况）
--------------------------------------------------------------------------------
*/
LUAI_FUNC l_noret luaG_opinterror(lua_State *L, const TValue *p1,
                                  const TValue *p2,
                                  const char *msg);

/*
--------------------------------------------------------------------------------
函数：luaG_tointerror - 转换为整数错误报告
--------------------------------------------------------------------------------
【函数原型】
l_noret luaG_tointerror (lua_State *L, const TValue *p1, const TValue *p2)

【参数说明】
- L:  Lua状态机指针
- p1: 第一个操作数（TValue*）
- p2: 第二个操作数（TValue*）

【返回值】
不返回（l_noret）

【功能详解】
处理需要整数但提供了非整数值的错误
某些操作要求操作数必须是整数，例如：
- 位运算（&, |, ^, ~, <<, >>）
- 整数除法（//）
- 某些表索引操作

【Lua的数字类型】
Lua有两种数字类型：
1. integer（整数）：例如 1, 2, 100
2. float（浮点数）：例如 1.5, 3.14

【错误示例】
1. 3.14 & 5     -- 位与运算需要整数
2. 10 >> 2.5    -- 位移运算需要整数

【使用场景】
- 位运算指令执行前的类型检查
- 确保操作数是整数类型
--------------------------------------------------------------------------------
*/
LUAI_FUNC l_noret luaG_tointerror(lua_State *L, const TValue *p1,
                                  const TValue *p2);

/*
--------------------------------------------------------------------------------
函数：luaG_ordererror - 顺序比较错误报告
--------------------------------------------------------------------------------
【函数原型】
l_noret luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2)

【参数说明】
- L:  Lua状态机指针
- p1: 第一个操作数（TValue*）
- p2: 第二个操作数（TValue*）

【返回值】
不返回（l_noret）

【功能详解】
处理顺序比较操作（<, >, <=, >=）的错误
Lua只允许以下类型进行顺序比较：
- 两个数字
- 两个字符串
- 有__lt或__le元方法的表/用户数据

【错误示例】
1. 1 < "2"         -- 数字和字符串无法比较
2. {} < {}         -- 没有元方法的表无法比较
3. true > false    -- 布尔值无法比较

【与相等比较的区别】
- 相等比较（==, ~=）：任意两个值都可以比较
- 顺序比较（<, >, <=, >=）：只能比较相同类型

【使用场景】
- 比较运算指令（OP_LT, OP_LE, OP_GT, OP_GE）执行时
- sort函数中的比较操作
--------------------------------------------------------------------------------
*/
LUAI_FUNC l_noret luaG_ordererror(lua_State *L, const TValue *p1,
                                  const TValue *p2);

/*
--------------------------------------------------------------------------------
函数：luaG_errnnil - Nil值访问错误报告
--------------------------------------------------------------------------------
【函数原型】
l_noret luaG_errnnil (lua_State *L, LClosure *cl, int k)

【参数说明】
- L:  Lua状态机指针
- cl: Lua闭包指针（LClosure*）
- k:  upvalue或常量索引

【返回值】
不返回（l_noret）

【功能详解】
处理访问nil值的upvalue或常量的错误
提供更具体的错误信息，指出是哪个upvalue或常量

【upvalue说明】
upvalue是闭包捕获的外部局部变量
例如：
  function outer()
    local x = 10
    function inner()
      print(x)  -- x是inner的upvalue
    end
  end

【使用场景】
- 访问未初始化的upvalue
- 访问已被回收的外部变量
- 某些特殊的nil访问情况

【错误消息示例】
"attempt to use a closed upvalue"
--------------------------------------------------------------------------------
*/
LUAI_FUNC l_noret luaG_errnnil(lua_State *L, LClosure *cl, int k);

/*
--------------------------------------------------------------------------------
函数：luaG_runerror - 运行时错误报告（可变参数）
--------------------------------------------------------------------------------
【函数原型】
l_noret luaG_runerror (lua_State *L, const char *fmt, ...)

【参数说明】
- L:   Lua状态机指针
- fmt: 格式化字符串（类似printf）
- ...: 可变参数列表

【返回值】
不返回（l_noret）

【功能详解】
生成自定义的运行时错误消息
使用printf风格的格式化字符串

【可变参数函数说明】
这是C语言的高级特性：
1. ...表示可以接受任意数量的额外参数
2. 需要使用<stdarg.h>中的va_list, va_start, va_end等宏处理
3. 类似于printf, scanf等标准库函数

【使用示例（C代码中）】
luaG_runerror(L, "invalid value for field '%s'", fieldname);
luaG_runerror(L, "stack overflow (depth=%d)", depth);

【格式化说明符】
- %s: 字符串
- %d: 整数
- %f: 浮点数
- 等等（标准printf格式）

【使用场景】
- 虚拟机内部各种运行时错误
- 需要包含动态信息的错误消息
- 自定义错误报告
--------------------------------------------------------------------------------
*/
LUAI_FUNC l_noret luaG_runerror(lua_State *L, const char *fmt, ...);

/*
--------------------------------------------------------------------------------
函数：luaG_addinfo - 添加源代码位置信息到错误消息
--------------------------------------------------------------------------------
【函数原型】
const char *luaG_addinfo (lua_State *L, const char *msg, TString *src, int line)

【参数说明】
- L:    Lua状态机指针
- msg:  原始错误消息
- src:  源文件名（TString*）
- line: 行号

【返回值】
返回带有位置信息的完整错误消息字符串

【功能详解】
在错误消息前添加源代码位置信息
格式：[源文件:行号]: 错误消息

【TString说明】
TString是Lua内部的字符串表示：
- 不是普通的char*
- 是一个结构体，包含长度和内容
- 所有字符串都经过内部化（interning），相同的字符串共享存储

【错误消息格式示例】
输入：msg="attempt to call a nil value", src="test.lua", line=10
输出："test.lua:10: attempt to call a nil value"

【使用场景】
- 在错误报告前添加文件名和行号
- 生成完整的错误追踪信息
- 帮助用户定位错误位置

【与调用栈的关系】
这个函数只添加单个位置信息
完整的调用栈信息由其他函数生成
--------------------------------------------------------------------------------
*/
LUAI_FUNC const char *luaG_addinfo(lua_State *L, const char *msg,
                                   TString *src, int line);

/*
--------------------------------------------------------------------------------
函数：luaG_errormsg - 错误消息处理和传播
--------------------------------------------------------------------------------
【函数原型】
l_noret luaG_errormsg (lua_State *L)

【参数说明】
- L: Lua状态机指针

【返回值】
不返回（l_noret）

【功能详解】
处理并传播错误消息的核心函数：
1. 从栈顶获取错误消息
2. 调用错误处理函数（如果有的话）
3. 通过longjmp传播错误

【错误处理流程】
1. 检查是否有错误处理函数（error handler）
   - 可以通过lua_pcall/lua_call的参数设置
2. 如果有，调用错误处理函数
   - 错误处理函数可以修改或包装错误消息
   - 例如添加调用栈信息
3. 使用longjmp跳转到最近的错误捕获点

【longjmp说明】
longjmp是C标准库函数（<setjmp.h>）：
- 实现非本地跳转（类似于异常处理）
- 跳转到之前setjmp设置的点
- Lua用它实现错误处理和协程切换

【使用场景】
- 所有错误报告函数最终都会调用此函数
- 实现Lua的错误传播机制
- 确保错误能被正确捕获和处理
--------------------------------------------------------------------------------
*/
LUAI_FUNC l_noret luaG_errormsg(lua_State *L);

/*
--------------------------------------------------------------------------------
函数：luaG_traceexec - 追踪指令执行（Hook支持）
--------------------------------------------------------------------------------
【函数原型】
int luaG_traceexec (lua_State *L, const Instruction *pc)

【参数说明】
- L:  Lua状态机指针
- pc: 当前程序计数器（即将执行的指令）

【返回值】
返回整数，可能的值：
- 0: 正常继续执行
- 非0: 需要特殊处理（例如Hook改变了执行流程）

【功能详解】
在指令执行前的追踪和Hook处理：
1. 检查是否需要触发Hook
2. 处理行Hook（LUA_MASKLINE）
3. 处理计数Hook（LUA_MASKCOUNT）
4. 调用用户设置的Hook回调函数

【Hook类型】
LUA_MASKLINE：每执行到新的源代码行时触发
- 需要查询行号信息
- 与上次触发的行号比较
LUA_MASKCOUNT：每执行指定数量的指令后触发
- 使用hookcount计数器

【性能考虑】
此函数可能频繁调用，因此：
1. 首先检查是否启用了Hook（快速路径）
2. 只在必要时才进行复杂的处理
3. 使用内联优化（在某些编译器中）

【使用场景】
- 实现debug.sethook()功能
- 支持调试器单步执行
- 性能分析和代码覆盖率工具
- 沙箱环境中的指令计数限制
--------------------------------------------------------------------------------
*/
LUAI_FUNC int luaG_traceexec(lua_State *L, const Instruction *pc);

/*
--------------------------------------------------------------------------------
函数：luaG_tracecall - 追踪函数调用（Hook支持）
--------------------------------------------------------------------------------
【函数原型】
int luaG_tracecall (lua_State *L)

【参数说明】
- L: Lua状态机指针

【返回值】
返回整数：
- 0: 正常继续执行
- 非0: 需要特殊处理

【功能详解】
在函数调用时的追踪和Hook处理：
1. 检查是否需要触发调用Hook（LUA_MASKCALL）
2. 调用用户设置的Hook回调函数
3. 传递调用事件信息给Hook

【与luaG_traceexec的区别】
- luaG_traceexec: 在每条指令前调用（频繁）
- luaG_tracecall: 仅在函数调用时调用（不频繁）

【Hook事件信息】
调用Hook时会提供：
- 事件类型：LUA_HOOKCALL
- 当前函数信息
- 调用位置（源文件和行号）

【配对的Hook】
通常与返回Hook（LUA_MASKRET）配对使用：
- CALL Hook: 函数调用时触发
- RETURN Hook: 函数返回时触发
- 可以用来测量函数执行时间

【使用场景】
- 实现函数调用追踪
- 调试器的"step into"功能
- 性能分析（profiling）
- 函数调用统计
--------------------------------------------------------------------------------
*/
LUAI_FUNC int luaG_tracecall(lua_State *L);

#endif

/*
================================================================================
文件总结：ldebug.h - Lua调试接口完整说明
================================================================================

【整体架构】
本文件是Lua调试系统的核心接口，提供了：
1. 调试信息获取（行号、局部变量）
2. 错误报告机制（各种类型错误）
3. Hook机制支持（追踪执行）

【关键技术点】

1. 行号信息的压缩存储
   - 使用相对行号（lineinfo）节省空间
   - 定期插入绝对行号（abslineinfo）作为锚点
   - ABSLINEINFO标记和MAXIWTHABS配置实现灵活的存储策略

2. 错误处理的设计模式
   - 所有错误函数都标记为l_noret（不返回）
   - 使用longjmp实现错误传播（类似异常机制）
   - 提供多层次的错误报告：通用错误、特定操作错误
   - 错误消息包含详细的类型和位置信息

3. Hook机制的实现
   - 支持多种Hook类型（调用、返回、行、计数）
   - 使用计数器实现高效的Hook触发检查
   - traceexec和tracecall配合实现完整的追踪功能

【C语言高级特性使用】

1. 宏定义（Macro）
   - pcRel: 指针运算和类型转换
   - ci_func: 多层宏嵌套，实现类型提取
   - resethookcount: 简单的字段赋值包装

2. 可变参数函数（Variadic Function）
   - luaG_runerror使用...接受任意数量参数
   - 需要<stdarg.h>支持
   - 实现类似printf的格式化输出

3. 函数指针和回调
   - Hook机制使用函数指针
   - 允许用户注册自定义回调函数

4. 非本地跳转（setjmp/longjmp）
   - 错误传播使用longjmp
   - 类似于C++的异常处理机制
   - 需要careful管理资源清理

5. 类型安全性
   - 使用const修饰符保护只读数据
   - 明确的类型转换（cast_int等）
   - TValue统一值表示，增强类型安全

【调试信息的使用流程】

1. 编译时
   - Lua编译器生成lineinfo和abslineinfo数组
   - 记录每条指令与源代码行的对应关系
   - 存储在Proto结构中

2. 运行时
   - 发生错误时，通过PC查询行号
   - luaG_getfuncline从调试信息中提取行号
   - luaG_addinfo添加位置信息到错误消息

3. 调试时
   - 设置Hook追踪执行
   - 使用luaG_findlocal查询变量
   - 生成完整的调用栈和状态信息

【错误处理的完整流程】

1. 检测错误
   - 虚拟机执行指令时检查类型
   - 发现类型不匹配或非法操作

2. 生成错误消息
   - 调用对应的错误报告函数（luaG_typeerror等）
   - 收集详细信息（类型、操作、位置）

3. 添加位置信息
   - luaG_addinfo添加源文件和行号
   - 格式化为用户友好的消息

4. 传播错误
   - luaG_errormsg处理错误消息
   - 调用错误处理函数（如果有）
   - 使用longjmp跳转到错误捕获点

5. 捕获和处理
   - lua_pcall捕获错误
   - 用户代码处理错误或继续传播

【性能优化策略】

1. 行号信息压缩
   - 相对行号使用小整数，减少内存
   - 2的幂次间隔（MAXIWTHABS）支持位运算优化

2. Hook的快速检查
   - 首先检查是否启用Hook
   - 只在必要时才进行详细处理

3. 错误消息的延迟构建
   - 只在真正需要时才格式化错误消息
   - 避免不必要的字符串操作

【与其他模块的关系】

1. lstate.h
   - 提供lua_State和CallInfo定义
   - 调试函数需要访问状态机

2. lobject.h
   - 提供TValue, Proto等类型定义
   - 调试需要理解值的内部表示

3. lvm.c
   - 虚拟机在执行过程中调用调试函数
   - 实现Hook和错误检查

4. lapi.c
   - 暴露调试功能给Lua API
   - 实现debug库的底层支持

【典型使用模式】

1. 错误报告
   if (!ttisfunction(o))
     luaG_typeerror(L, o, "call");

2. 行号查询
   int line = luaG_getfuncline(ci_func(ci)->p, pcRel(pc, p));

3. Hook设置
   L->hook = my_hook_function;
   L->hookmask = LUA_MASKCALL | LUA_MASKRET;
   resethookcount(L);

【学习建议】

1. 首先理解Lua的值表示（TValue）
2. 学习函数调用机制（CallInfo）
3. 研究字节码格式（Instruction）
4. 理解错误处理的longjmp机制
5. 分析Hook的触发时机和流程

【扩展阅读】

- Lua源码：lvm.c（虚拟机实现）
- Lua源码：ldebug.c（调试函数实现）
- Lua手册：debug库文档
- C标准库：setjmp.h, stdarg.h文档

================================================================================
*/