/*
** ============================================================================
** 文件概要说明
** ============================================================================
** 文件名: lapi.h
** 原始标识: $Id: lapi.h $
** 功能描述: Lua API 辅助函数和宏定义
** 版权声明: 参见 lua.h 中的版权声明
**
** 【文件整体功能】
** 这个头文件是 Lua 核心 API 的内部辅助文件,定义了一系列用于 API 实现的宏和检查机制。
** 主要用于:
** 1. 栈操作的安全检查(防止栈溢出、栈下溢等)
** 2. API 调用的断言检查(用于调试和测试)
** 3. 线程锁定机制的定义(用于多线程环境)
** 4. 函数调用结果的调整处理
**
** 【关键概念】
** - Lua 栈: Lua C API 通过一个虚拟栈在 C 和 Lua 之间传递值
** - 栈顶(top): 指向栈中下一个可用位置
** - 调用信息(ci): 记录当前函数调用的状态信息
** - TBC列表(to-be-closed): 记录需要在作用域结束时关闭的变量
**
** 【依赖关系】
** - llimits.h: Lua 的基础限制和类型定义
** - lstate.h: Lua 状态机的定义
** ============================================================================
*/

#ifndef lapi_h 
#define lapi_h

#include "llimits.h" /* 包含 Lua 的基本限制定义,如整数范围、内存限制等 */
#include "lstate.h"  /* 包含 Lua 状态机(lua_State)的结构定义 */

/*
** ============================================================================
** API 检查机制
** ============================================================================
** 这部分定义了 api_check 宏,用于在 API 调用时进行断言检查。
** 根据是否定义了 LUA_USE_APICHECK,有两种不同的实现方式。
*/

#if defined(LUA_USE_APICHECK)
/*
** 【开发模式 - 使用标准 assert】
** 当定义了 LUA_USE_APICHECK 时,使用 C 标准库的 assert 进行检查。
** 这种方式在断言失败时会直接终止程序并输出错误信息,适合开发调试。
**
** 参数说明:
**   l - lua_State 指针(在这个版本中未使用,但保留参数以保持接口一致)
**   e - 要检查的条件表达式
**   msg - 错误消息(在标准 assert 中未使用)
*/
#include <assert.h>
#define api_check(l, e, msg) assert(e)

#else /* for testing */
/*
** 【测试/发布模式 - 使用 Lua 自定义断言】
** 当未定义 LUA_USE_APICHECK 时,使用 Lua 内部的 lua_assert 进行检查。
**
** 宏展开说明:
**   ((void)(l), lua_assert((e) && msg))
**   - (void)(l): 将 l 转为 void 类型,避免"未使用参数"的编译警告
**   - (e) && msg: 条件 e 必须为真,且 msg 提供错误描述信息
**   - lua_assert: Lua 内部定义的断言宏,可能在发布版本中被编译为空操作
**
** 使用逗号运算符的技巧:
**   逗号运算符 (expr1, expr2) 会先执行 expr1,然后执行 expr2,整个表达式的值为 expr2 的值。
**   这里用来先处理 l 参数(避免警告),然后执行真正的断言检查。
*/
#define api_check(l, e, msg) ((void)(l), lua_assert((e) && msg))
#endif

/*
** ============================================================================
** 栈顶递增宏 - api_incr_top
** ============================================================================
** 功能: 将 Lua 栈顶指针向上移动一个位置(压入一个元素后调用)
**
** 【详细说明】
** 这个宏执行两个操作:
** 1. L->top.p++: 将栈顶指针向上移动一个位置
** 2. api_check(...): 检查栈是否溢出
**
** 【栈溢出检查】
** 条件: L->top.p <= L->ci->top.p
**   - L->top.p: 当前实际的栈顶位置
**   - L->ci->top.p: 当前调用信息允许的最大栈顶位置
**   - 如果 top.p 超过了 ci->top.p,说明栈空间不足,发生溢出
**
** 【使用场景】
** 每当向 Lua 栈压入一个新值后,都需要调用此宏更新栈顶指针。
** 例如: lua_pushinteger、lua_pushstring 等函数内部都会使用此宏。
*/
/* Increments 'L->top.p', checking for stack overflows */
/* 递增 'L->top.p',同时检查栈溢出 */
#define api_incr_top(L) \
    (L->top.p++, api_check(L, L->top.p <= L->ci->top.p, "stack overflow"))

/*
** ============================================================================
** 线程锁定机制宏
** ============================================================================
** 功能: 定义进入和离开 Lua 核心代码时执行的宏
**
** 【设计目的】
** 在多线程环境中,这些宏可以被重定义为实际的互斥锁操作,保证线程安全。
** 在单线程环境中,它们被定义为空操作,不产生任何开销。
**
** 【宏定义说明】
** - lua_lock(L): 在进入 Lua 核心代码前调用(例如开始执行 Lua API 函数)
** - lua_unlock(L): 在离开 Lua 核心代码后调用(例如 API 函数返回前)
** - ((void) 0): C 语言中的空语句,不做任何操作
**
** 【如何自定义】
** 在编译时可以通过 -D 选项或在包含此头文件前定义这些宏:
**   #define lua_lock(L) pthread_mutex_lock(&global_mutex)
**   #define lua_unlock(L) pthread_mutex_unlock(&global_mutex)
**
** 【注意事项】
** 如果自定义了这些宏,必须确保:
** 1. 每个 lua_lock 都有对应的 lua_unlock
** 2. 不能在持有锁的情况下调用可能阻塞的操作
** 3. 避免死锁情况
*/
/*
** macros that are executed whenever program enters the Lua core
** ('lua_lock') and leaves the core ('lua_unlock')
*/
/* 宏定义:程序进入 Lua 核心时执行 ('lua_lock'),离开核心时执行 ('lua_unlock') */
#if !defined(lua_lock)
#define lua_lock(L) ((void)0)
#define lua_unlock(L) ((void)0)
#endif

/*
** ============================================================================
** 调整函数返回结果宏 - adjustresults
** ============================================================================
** 功能: 处理函数调用返回多个值时的栈空间调整
**
** 【背景知识】
** Lua 函数可以返回多个值。当被调用的函数返回的值多于调用者预期时,
** 可能需要调整调用者的栈顶指针,以容纳所有返回值。
**
** 【宏参数】
** - L: lua_State 指针
** - nres: 期望的返回值数量
**   * 如果 nres >= 0: 期望固定数量的返回值
**   * 如果 nres == LUA_MULTRET: 接受所有返回值(多返回值模式)
**
** 【调整逻辑】
** 条件: (nres) <= LUA_MULTRET && L->ci->top.p < L->top.p
** 1. (nres) <= LUA_MULTRET: 检查是否是多返回值模式
**    - LUA_MULTRET 通常定义为 -1,表示接受任意数量的返回值
**    - 如果 nres > LUA_MULTRET(即 nres >= 0),不需要调整
**
** 2. L->ci->top.p < L->top.p: 实际栈顶超出了当前调用信息的栈顶
**    - L->top.p: 实际的栈顶(包含所有返回值)
**    - L->ci->top.p: 调用信息中记录的栈顶
**    - 如果实际栈顶更高,说明返回值超出预期,需要扩展 ci->top.p
**
** 3. L->ci->top.p = L->top.p: 调整调用信息的栈顶以容纳所有返回值
**
** 【使用示例】
** 假设函数 f() 被调用,期望返回 2 个值,但实际返回了 5 个值:
** - 调用前: ci->top.p 设置为能容纳 2 个返回值
** - 调用后: top.p 实际移动到了 5 个返回值的位置
** - adjustresults 将 ci->top.p 调整到 top.p,避免后续操作出错
*/
/*
** If a call returns too many multiple returns, the callee may not have
** stack space to accommodate all results. In this case, this macro
** increases its stack space ('L->ci->top.p').
*/
/* 如果一个调用返回了太多的多返回值,被调用者可能没有足够的栈空间
** 来容纳所有结果。在这种情况下,此宏会增加其栈空间 ('L->ci->top.p')。
*/
#define adjustresults(L, nres)                                \
    {                                                         \
        if ((nres) <= LUA_MULTRET && L->ci->top.p < L->top.p) \
            L->ci->top.p = L->top.p;                          \
    }

/*
** ============================================================================
** 检查栈元素数量宏 - api_checknelems
** ============================================================================
** 功能: 确保栈中至少有 n 个元素可用
**
** 【详细说明】
** 这个宏用于在执行栈操作前验证栈中有足够的元素。
**
** 【计算逻辑】
** 条件: (n) < (L->top.p - L->ci->func.p)
**
** - L->top.p: 当前栈顶指针(指向下一个可用位置)
** - L->ci->func.p: 当前函数在栈中的位置
** - L->top.p - L->ci->func.p: 栈中实际存储的元素数量
**   * func.p 指向当前执行的函数对象
**   * func.p 上方的所有位置都是可用的栈元素
**   * 这个差值就是当前栈中的元素总数
**
** - (n) < (元素总数): 检查所需的 n 个元素是否存在
**   * 如果 n >= 元素总数,说明栈中元素不足,触发断言
**
** 【使用场景】
** 在执行需要从栈中获取参数的操作前调用,例如:
** - lua_tonumber(L, -1): 需要至少 1 个元素
** - lua_concat(L, 3): 需要至少 3 个元素
**
** 【栈布局示意】
** 低地址 -> 高地址:
** [...] [func] [arg1] [arg2] [arg3] [空] <- top.p
**        ^                            ^
**        func.p                      top.p
**        |<--- (top.p - func.p) --->|
**        这个距离就是栈中的元素数量
*/
/* Ensure the stack has at least 'n' elements */
/* 确保栈中至少有 'n' 个元素 */
#define api_checknelems(L, n)                      \
    api_check(L, (n) < (L->top.p - L->ci->func.p), \
              "not enough elements in the stack")

/*
** ============================================================================
** 检查可弹出元素数量宏 - api_checkpop
** ============================================================================
** 功能: 确保栈中至少有 n 个元素可以被安全弹出
**
** 【详细说明】
** 这个宏比 api_checknelems 更严格,它不仅检查元素数量,还要考虑
** to-be-closed (TBC) 变量的影响。
**
** 【检查条件】
** 需要同时满足两个条件:
**
** 1. (n) < L->top.p - L->ci->func.p
**    - 与 api_checknelems 相同,确保有足够的元素
**
** 2. L->tbclist.p < L->top.p - (n)
**    - L->tbclist.p: to-be-closed 变量列表的指针
**    - L->top.p - (n): 弹出 n 个元素后的栈顶位置
**    - 这个条件确保弹出操作不会影响到需要关闭的变量
**
** 【TBC (To-Be-Closed) 变量】
** Lua 5.4 引入了 <close> 标记,允许变量在离开作用域时自动调用清理函数。
** 这些变量记录在 tbclist 中。如果弹出操作会移除这些变量,可能导致
** 资源泄漏或清理函数不被调用。
**
** 【为什么需要第二个条件】
** 考虑以下情况:
**   local x <close> = some_resource()  -- x 在 tbclist 中
**   -- 此时如果 API 试图弹出包含 x 的元素,会违反 TBC 约定
**
** 第二个条件保证:
** - tbclist.p < top.p - n: TBC变量的位置要低于弹出后的栈顶
** - 这样弹出操作不会影响到任何 TBC 变量
**
** 【注释中的说明】
** "Some functions only update a slot after checking it for popping"
** "某些函数只在检查可以弹出后才更新插槽"
**
** 这是一个优化说明:有些函数会先检查能否弹出,然后执行"弹出+压入"
** 的组合操作。这个检查保证了即使是这种优化场景也是安全的。
**
** 【使用场景】
** - lua_pop(L, n): 弹出 n 个元素
** - lua_remove(L, index): 移除指定位置的元素
** - lua_replace(L, index): 替换指定位置的元素(先弹出再压入)
*/
/* Ensure the stack has at least 'n' elements to be popped. (Some
** functions only update a slot after checking it for popping, but that
** is only an optimization for a pop followed by a push.)
*/
/* 确保栈中至少有 'n' 个元素可以被弹出。(某些函数只在检查可以弹出后
** 才更新插槽,但这只是弹出后紧跟压入操作的一种优化。)
*/
#define api_checkpop(L, n)                                                        \
    api_check(L, (n) < L->top.p - L->ci->func.p && L->tbclist.p < L->top.p - (n), \
              "not enough free elements in the stack")

#endif

/*
** ============================================================================
** 文件总结说明
** ============================================================================
**
** 【整体架构】
** 这个头文件是 Lua C API 实现的基础设施层,提供了一套宏定义来保证
** API 调用的安全性和正确性。所有这些宏都是内联的(编译时展开),
** 因此在发布版本中可以通过条件编译优化掉,几乎没有运行时开销。
**
** 【核心宏总结】
**
** 1. api_check - API 断言检查
**    - 用途: 在开发阶段捕获 API 误用
**    - 实现: 可配置使用标准 assert 或 Lua 内部断言
**    - 影响: 在发布版本中可以完全禁用
**
** 2. api_incr_top - 栈顶递增
**    - 用途: 压入元素后移动栈顶指针
**    - 检查: 防止栈溢出
**    - 频率: 每次 push 操作都会调用
**
** 3. lua_lock / lua_unlock - 线程同步
**    - 用途: 多线程环境下的互斥访问
**    - 默认: 空操作(适合单线程)
**    - 自定义: 可重定义为实际的锁机制
**
** 4. adjustresults - 调整返回值
**    - 用途: 处理多返回值情况
**    - 时机: 函数调用返回后
**    - 逻辑: 扩展调用者栈空间以容纳所有返回值
**
** 5. api_checknelems - 检查元素数量
**    - 用途: 确保有足够的元素可操作
**    - 计算: 基于 top.p 和 func.p 的距离
**    - 场景: 读取栈元素前
**
** 6. api_checkpop - 检查可弹出数量
**    - 用途: 确保弹出操作安全
**    - 额外检查: 考虑 TBC 变量的影响
**    - 场景: 弹出或移除栈元素前
**
** 【设计模式】
**
** 1. 防御性编程
**    - 每个可能出错的操作都有对应的检查宏
**    - 在开发阶段及早发现问题
**    - 在发布阶段可以优化掉检查以提高性能
**
** 2. 宏的使用
**    - 优点: 零运行时开销,类型安全,可内联
**    - 技巧: 使用逗号运算符组合多个操作
**    - 注意: 参数可能被多次求值,需要小心副作用
**
** 3. 条件编译
**    - 通过 #if defined 支持不同的编译配置
**    - 开发版本启用所有检查
**    - 发布版本可以移除检查以提高性能
**
** 【关键数据结构关系】
**
** lua_State (L):
**   ├─ top.p          : 栈顶指针(下一个可用位置)
**   ├─ ci             : 当前调用信息
**   │   ├─ func.p     : 当前函数在栈中的位置
**   │   └─ top.p      : 当前调用允许的最大栈顶
**   └─ tbclist.p      : to-be-closed 变量列表
**
** 栈空间关系:
**   func.p <= 栈元素 < top.p <= ci->top.p
**   tbclist.p 指向需要关闭的变量(如果有)
**
** 【与其他模块的关系】
**
** - llimits.h: 提供基础类型定义(如 lua_assert 的定义)
** - lstate.h: 提供 lua_State 结构的完整定义
** - lapi.c: 实际的 API 函数实现,会大量使用这些宏
** - lvm.c: Lua 虚拟机,也会使用这些栈操作宏
**
** 【使用建议】
**
** 1. 学习 Lua 内部实现时:
**    - 先理解 Lua 栈的概念
**    - 再理解 CallInfo 的作用
**    - 最后理解这些宏如何保护栈操作
**
** 2. 修改或扩展 Lua 时:
**    - 在开发时启用 LUA_USE_APICHECK
**    - 使用这些宏而不是直接操作指针
**    - 确保所有栈操作都有相应的检查
**
** 3. 多线程应用:
**    - 定义自己的 lua_lock 和 lua_unlock
**    - 确保粒度合适(既要安全又要高效)
**    - 测试死锁和竞态条件
**
** 【性能考虑】
**
** - 宏展开是编译时操作,不影响运行时性能
** - api_check 在发布版本中可以完全消除
** - 栈操作的检查开销极小(只是指针比较)
** - 对性能敏感的代码可以在确保安全后禁用某些检查
**
** 【常见陷阱】
**
** 1. 忘记调用 api_incr_top 导致栈状态不一致
** 2. 在持有 lua_lock 时调用阻塞操作导致死锁
** 3. 弹出元素时忽略 TBC 变量导致资源泄漏
** 4. 直接操作 L->top.p 而不使用宏导致检查失效
**
** ============================================================================
*/