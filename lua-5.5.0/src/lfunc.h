/*
** $Id: lfunc.h $
** 辅助函数用于操作原型(prototypes)和闭包(closures)
** 参见 lua.h 中的版权声明
*/

#ifndef lfunc_h
#define lfunc_h

#include "lobject.h"

/*
** ===================================================================
** 文件概要
** ===================================================================
**
** 本文件是Lua虚拟机中管理函数原型和闭包的核心头文件。
**
** 主要功能:
** 1. 定义闭包内存布局计算宏 - 用于计算C闭包和Lua闭包所需的内存大小
** 2. 定义上值(upvalue)的管理宏 - 用于检查和操作闭包捕获的外部变量
** 3. 声明创建和销毁函数对象的函数接口 - 如创建新原型、新闭包等
** 4. 声明上值生命周期管理函数 - 如查找、初始化、关闭上值等
**
** 核心概念:
** - Proto: 函数原型，包含字节码、常量、调试信息等
** - CClosure: C语言编写的闭包，包含C函数指针和上值
** - LClosure: Lua语言编写的闭包，包含指向原型的指针和上值
** - UpVal: 上值，代表闭包捕获的外部作用域中的变量
**
** ===================================================================
*/

/*
** -------------------------------------------------------------------
** 宏定义: 闭包内存大小计算
** -------------------------------------------------------------------
** 这两个宏用于计算分配闭包时所需的内存大小。offsetof()是C标准库
** 宏，用于计算结构体中某个成员相对于结构体起始地址的偏移量。
** 通过这个方法，可以为可变数量的上值预分配空间。
*/

#define sizeCclosure(n) \
	(offsetof(CClosure, upvalue) + sizeof(TValue) * cast_uint(n))
/*
** 计算C闭包的内存大小
** 参数 n: 上值的数量
** 计算方法:
**   - offsetof(CClosure, upvalue): 从CClosure结构体起始地址到upvalue字段的偏移量
**     这给出了结构体中固定部分的大小
**   - sizeof(TValue) * cast_uint(n): n个TValue(Lua值)的总大小
**   - 两者相加得到完整的闭包大小，因为upvalue是一个柔性数组成员
**
** 使用场景: 在luaF_newCclosure()中分配内存时使用
*/

#define sizeLclosure(n) \
	(offsetof(LClosure, upvals) + sizeof(UpVal *) * cast_uint(n))
/*
** 计算Lua闭包的内存大小
** 参数 n: 上值的数量
** 计算方法:
**   - offsetof(LClosure, upvals): 从LClosure结构体起始地址到upvals字段的偏移量
**   - sizeof(UpVal *) * cast_uint(n): n个UpVal指针的总大小
**   - 两者相加得到完整的闭包大小
**
** 关键区别: Lua闭包存储的是UpVal指针，而非直接的TValue
** 使用场景: 在luaF_newLclosure()中分配内存时使用
*/

/*
** -------------------------------------------------------------------
** 宏定义: 线程上值列表管理
** -------------------------------------------------------------------
*/

#define isintwups(L) (L->twups != L)
/*
** 检查线程L是否在'twups'列表中
** 参数 L: lua_State指针，代表一个Lua执行线程
**
** 工作原理:
**   twups是一个指向UpVal结构体的指针，形成一个双链表。
**   如果L->twups == L，表示该线程不在twups链表中(或列表为空)
**   如果L->twups != L，表示该线程已经链接到twups列表中
**
** 用途: Lua使用twups列表来追踪所有包含未关闭上值的线程。
**   当线程被垃圾收集时，需要关闭其上值。这个宏用于快速检查
**   该线程是否需要这样的处理。
**
** 返回值: true(非零)表示在列表中，false(0)表示不在列表中
*/

/*
** -------------------------------------------------------------------
** 宏定义: 上值数量限制
** -------------------------------------------------------------------
*/

#define MAXUPVAL 255
/*
** 闭包中上值的最大数量限制(C闭包和Lua闭包都适用)
**
** 限制原因:
**   - 该值必须能适配在一个VM寄存器中
**   - Lua VM使用8位字节来存储指令中的上值索引
**   - 因此最大值为255 (0-255共256个值)
**
** 这是一个硬性限制，在Lua编译器验证字节码时会检查这个限制。
*/

/*
** -------------------------------------------------------------------
** 宏定义: 上值状态检查
** -------------------------------------------------------------------
*/

#define upisopen(up) ((up)->v.p != &(up)->u.value)
/*
** 检查上值是否处于"开放"状态
** 参数 up: UpVal指针，指向一个上值结构体
**
** 工作原理:
**   UpVal结构体包含一个联合体v，它有两种状态:
**   1. "开放"状态: 上值引用栈中的一个活动变量
**      此时 v.p 指向栈上的实际位置(不等于 &u.value)
**   2. "关闭"状态: 上值引用已经被捕获的值
**      此时 v.p 指向 &u.value，即上值结构体内部的存储位置
**
** 返回值: true(非零)表示开放，false(0)表示已关闭
**
** 用途: 垃圾收集和上值管理需要区别对待开放和已关闭的上值
*/

#define uplevel(up) check_exp(upisopen(up), cast(StkId, (up)->v.p))
/*
** 获取开放上值所指向的栈位置
** 参数 up: UpVal指针，必须指向一个开放的上值
**
** 工作原理:
**   - check_exp(upisopen(up), ...): 检查表达式宏
**     在调试模式下检查up确实是开放的上值
**     在发布模式下会被优化掉
**   - cast(StkId, (up)->v.p): 将v.p(通用指针)转换为StkId类型
**     StkId通常是 TValue* 的别名
**
** 返回值: 栈上上值所指向的位置(StkId类型)
**
** 注意: 此宏只能用于开放状态的上值。如果用于已关闭的上值，
**   在调试模式下会触发断言失败。
**
** 用途: 需要直接访问上值在栈上的变量时使用
*/

/*
** -------------------------------------------------------------------
** 宏定义: 闭包缓存管理
** -------------------------------------------------------------------
*/

#define MAXMISS 10
/*
** 放弃使用原型中闭包缓存前允许的最大失误次数
**
** 工作原理:
**   Lua为函数原型维护一个闭包缓存，用于快速查找现有闭包。
**   如果缓存查询失败次数超过MAXMISS(10次)，Lua会放弃使用缓存。
**   这是一个性能优化策略：避免在某些情况下过度使用缓存。
**
** 场景示例:
**   如果一个函数频繁创建新闭包(每次都不命中缓存)，
**   在失误10次后，Lua就不再查询缓存，直接创建新闭包。
**
** 值的选择: 10是经验值，平衡了缓存命中收益和查询开销
*/

/*
** -------------------------------------------------------------------
** 宏定义: 特殊的上值关闭状态
** -------------------------------------------------------------------
*/

#define CLOSEKTOP (LUA_ERRERR + 1)
/*
** 关闭上值时的特殊状态码，用于保留栈顶
**
** 工作原理:
**   当调用luaF_close()关闭上值时，可以传入不同的状态码:
**   - LUA_OK 或其他正常状态: 正常关闭上值
**   - CLOSEKTOP: 特殊状态，表示关闭上值但保留栈的当前顶部
**
**   LUA_ERRERR是错误状态码，CLOSEKTOP定义为LUA_ERRERR + 1，
**   这样可以将其作为一个特殊的"标记"值来区别对待。
**
** 使用场景:
**   在某些异常情况下(如垃圾收集扫描)，需要关闭上值但不改变栈状态。
**   此时传入CLOSEKTOP作为状态码。
**
** 细节: 这个值不会被记录为实际的执行状态，仅作为内部控制信号
*/

/*
** ===================================================================
** 函数声明: 原型和闭包的创建与初始化
** ===================================================================
*/

LUAI_FUNC Proto *luaF_newproto(lua_State *L);
/*
** 创建一个新的函数原型
** 参数:
**   L: Lua执行状态指针
** 返回值:
**   指向新创建的Proto结构体的指针
**
** 工作原理:
**   - 从堆内存中分配一个Proto结构体
**   - 初始化所有字段为默认值:
**     * 代码指针为NULL
**     * 常量表为空
**     * 嵌套原型列表为空
**     * 调试信息(行号、局部变量等)为空
**     * 参数数量、上值数量等为0
**   - 将新原型注册到垃圾收集系统
**
** 此函数是创建任何Lua函数的第一步。编译器在编译Lua函数时会调用它。
*/

LUAI_FUNC CClosure *luaF_newCclosure(lua_State *L, int nupvals);
/*
** 创建一个新的C闭包
** 参数:
**   L: Lua执行状态指针
**   nupvals: 上值的数量(闭包要捕获的外部变量个数)
** 返回值:
**   指向新创建的CClosure结构体的指针
**
** 工作原理:
**   - 使用sizeCclosure(nupvals)宏计算所需的内存大小
**   - 分配足够的内存来容纳CClosure结构体以及nupvals个TValue上值
**   - 初始化CClosure的各个字段:
**     * c: C函数指针(待后续设置)
**     * nupvals: 记录上值数量
**     * upvalue[0..nupvals-1]: 未初始化(待后续设置)
**   - 将新闭包注册到垃圾收集系统
**
** 使用场景:
**   当在Lua中注册一个C语言编写的函数时(如扩展库)，需要为其创建闭包。
**   例如: lua_pushcclosure()在C API中会调用此函数。
**
** 注意: 返回后，上值和函数指针都是未初始化的，调用者需要设置它们。
*/

LUAI_FUNC LClosure *luaF_newLclosure(lua_State *L, int nupvals);
/*
** 创建一个新的Lua闭包
** 参数:
**   L: Lua执行状态指针
**   nupvals: 上值的数量
** 返回值:
**   指向新创建的LClosure结构体的指针
**
** 工作原理:
**   - 使用sizeLclosure(nupvals)宏计算所需的内存大小
**   - 分配足够的内存来容纳LClosure结构体以及nupvals个UpVal指针
**   - 初始化LClosure的各个字段:
**     * p: 指向函数原型的指针(待后续设置)
**     * nupvals: 记录上值数量
**     * upvals[0..nupvals-1]: UpVal指针(待后续设置)
**   - 将新闭包注册到垃圾收集系统
**
** 使用场景:
**   当创建一个Lua函数对象时(从原型实例化)会调用此函数。
**   虚拟机执行 function 定义语句时会调用此函数。
**
** 与luaF_newCclosure的区别:
**   LClosure存储的是UpVal指针(指向上值对象)
**   CClosure存储的是直接的TValue值
**
** 注意: 返回后，原型指针和上值都是未初始化的。
*/

LUAI_FUNC void luaF_initupvals(lua_State *L, LClosure *cl);
/*
** 初始化Lua闭包的上值
** 参数:
**   L: Lua执行状态指针
**   cl: Lua闭包指针，要初始化其上值
** 返回值: 无
**
** 工作原理:
**   - 遍历cl->upvals数组中的所有nupvals个上值指针
**   - 对于每个上值位置，创建一个新的UpVal对象或链接到现有的上值
**   - 这个过程建立了闭包与它捕获的外部变量之间的联系
**
** 调用时机:
**   在luaF_newLclosure()之后，闭包的上值指针都指向NULL。
**   需要调用此函数来正式初始化和链接这些上值。
**
** 细节:
**   初始化过程涉及:
**   - 查找或创建表示外部变量的UpVal对象
**   - 将这些UpVal对象链接到闭包
**   - 维护上值的开放/关闭状态
**
** 相关函数: luaF_findupval() - 用于查找或创建单个上值
*/

/*
** ===================================================================
** 函数声明: 上值的生命周期管理
** ===================================================================
*/

LUAI_FUNC UpVal *luaF_findupval(lua_State *L, StkId level);
/*
** 查找或创建指向给定栈位置的上值
** 参数:
**   L: Lua执行状态指针
**   level: 栈上的目标位置(StkId通常是 TValue* 别名)
** 返回值:
**   指向UpVal结构体的指针。如果已存在指向level的上值，返回现有的；
**   否则创建一个新的上值并返回。
**
** 工作原理:
**   - 检查是否已有一个打开的上值指向同一栈位置
**   - 如果有，直接返回现有的上值(避免重复创建)
**   - 如果没有，创建一个新的UpVal对象:
**     * 设置v.p指向level(开放状态)
**     * 将其插入到全局上值链表中
**   - 返回上值指针
**
** Lua维护一个全局的开放上值链表，按栈位置排序。
** 这确保了多个闭包可以共享同一个上值(如果它们捕获同一变量)。
**
** 使用场景:
**   创建闭包时，对于每个被捕获的外部变量，都需要调用此函数
**   来获取对应的UpVal对象。
**
** 性能注意:
**   - 在开放上值较少时，简单的线性搜索很快
**   - 如果有数千个开放上值，可能需要优化搜索
*/

LUAI_FUNC void luaF_newtbcupval(lua_State *L, StkId level);
/*
** 创建一个新的"待关闭"(to-be-closed)上值
** 参数:
**   L: Lua执行状态指针
**   level: 栈上的目标位置
** 返回值: 无
**
** 工作原理:
**   - 创建一个特殊类型的上值，用于实现Lua 5.4的<close>特性
**   - 这种上值被标记为"待关闭"，意味着当其作用域结束时，
**     需要调用关联的元方法(__close)来清理资源
**   - 将其添加到一个特殊的"待关闭"上值链表中
**
** 关键概念 - "待关闭"变量(to-be-closed variables):
**   Lua 5.4引入了<close>属性，允许变量被标记为"待关闭"。
**   当这样的变量离开其作用域时，Lua会自动调用它的__close元方法。
**   这类似于C++的RAII或Python的context manager。
**
** 示例(Lua代码):
**   local file <close> = io.open("test.txt")
**   -- 当file作用域结束时，Lua会调用file的__close方法
**
** 实现细节:
**   - 上值被标记有特殊标记(如marked字段的某个标志位)
**   - 被加入到线程的tbclist(to-be-closed list)中
**   - 当作用域退出时，luaF_closeupval()会自动调用__close方法
*/

LUAI_FUNC void luaF_closeupval(lua_State *L, StkId level);
/*
** 关闭指定栈位置或更高位置的所有上值
** 参数:
**   L: Lua执行状态指针
**   level: 栈上的参考位置。所有指向level位置或高于level的上值都会被关闭
** 返回值: 无
**
** 工作原理:
**   - 遍历打开的上值链表
**   - 对于每个上值，检查它是否指向 >= level 的栈位置
**   - 如果是，关闭这个上值:
**     * 将其引用的值从栈复制到上值内部存储(u.value)
**     * 设置v.p指向u.value(关闭状态)
**     * 将其从打开上值链表中移除
**
** 关键过程 - 上值的"关闭":
**   打开状态: v.p -> 栈上的变量
**   关闭状态: v.p -> u.value (上值自身的存储)
**
**   关闭时会将值从栈复制到u.value，所以即使栈被重用或变化，
**   上值仍然保持对原始值的引用。
**
** 使用场景:
**   - 函数返回时，需要关闭函数的局部变量关联的上值
**   - 程序退出某个作用域时
**   - 垃圾收集时清理线程的上值
**
** 与luaF_newtbcupval的配合:
**   对于标记为"待关闭"的上值，关闭时会额外执行__close元方法调用。
*/

LUAI_FUNC StkId luaF_close(lua_State *L, StkId level, TStatus status, int yy);
/*
** 关闭上值并处理可能的错误
** 参数:
**   L: Lua执行状态指针
**   level: 参考栈位置(关闭 >= level 的所有上值)
**   status: 执行状态码，如LUA_OK、LUA_ERRRUN等
**           或特殊值CLOSEKTOP
**   yy: 控制标志(具体含义需参考实现)
** 返回值:
**   返回修改后的栈顶位置(StkId)
**
** 工作原理:
**   - 这是luaF_closeupval()的增强版本，处理异常情况
**   - 调用luaF_closeupval(L, level)来关闭上值
**   - 处理status参数:
**     * 如果status为CLOSEKTOP，保留栈顶不变
**     * 如果status为错误状态，可能需要处理错误栈帧
**   - 根据yy标志进行额外的处理
**   - 返回新的栈顶位置
**
** 这个函数与luaF_closeupval的区别:
**   - luaF_closeupval: 简单地关闭上值
**   - luaF_close: 关闭上值并处理复杂的状态(错误、栈管理等)
**
** 使用场景:
**   - 异常处理(错误发生时关闭上值)
**   - 需要精细控制栈状态的复杂流程
**
** 特殊情况:
**   如果status == CLOSEKTOP，函数会保留当前栈顶，
**   这在某些垃圾收集扫描或特殊清理流程中需要。
*/

LUAI_FUNC void luaF_unlinkupval(UpVal *uv);
/*
** 将上值从链表中卸载(移除)
** 参数:
**   uv: UpVal指针，要从链表中移除的上值
** 返回值: 无
**
** 工作原理:
**   - Lua维护一个双向链表来追踪所有打开的上值
**   - UpVal结构体包含prev和next指针用于链表维护
**   - 此函数更新链表指针，使得uv被从链表中移除:
**     * uv->prev->next = uv->next
**     * uv->next->prev = uv->prev
**
** 细节:
**   这是一个低级操作，通常在以下情况调用:
**   - 上值被垃圾收集
**   - 上值被关闭并不再需要
**   - 线程被销毁时清理其上值
**
** 与luaF_closeupval的区别:
**   - luaF_closeupval: 关闭上值(将打开状态变为关闭状态)
**   - luaF_unlinkupval: 从链表中移除上值
**
**   这两个操作通常一起进行，但分开是因为有时只需要移除而不关闭。
**
** 双链表的好处:
**   - 移除操作是O(1)时间复杂度(不需要遍历)
**   - 可以在任何地方插入或移除
**
** 注意: 卸载后，上值可能仍然存活(如果被某些闭包引用)，
**   但它不再参与全局打开上值的追踪。
*/

/*
** ===================================================================
** 函数声明: 原型的内存管理
** ===================================================================
*/

LUAI_FUNC lu_mem luaF_protosize(Proto *p);
/*
** 计算函数原型所占用的内存大小
** 参数:
**   p: Proto指针，要计算大小的函数原型
** 返回值:
**   返回字节数(lu_mem类型，通常是size_t或类似的无符号整数类型)
**
** 工作原理:
**   - 计算Proto结构体本身的大小
**   - 累加结构体内各个字段所占的内存:
**     * 字节码(code数组): p->sizecode * sizeof(Instruction)
**     * 常量表(k数组): p->sizek * sizeof(TValue)
**     * 嵌套原型指针(p数组): p->sizep * sizeof(Proto*)
**     * 参数信息: p->sizeupvals * sizeof(Upvaldesc)
**     * 调试信息(行号、局部变量等): p->sizelineinfo + p->sizevars + ...
**
** 用途:
**   - 垃圾收集系统使用此函数来追踪总内存使用量
**   - 对于增量式垃圾收集，需要知道对象的大小来平衡回收步数
**   - 用户可以查询原型占用的内存来进行内存分析
**
** 注意:
**   此函数计算的是原型本身及其直接包含的数据的大小。
**   不包括:
**   - 嵌套原型内容(它们有各自的Proto对象)
**   - 常量中的对象内容(字符串、表等有各自的对象)
**
** 设计原因:
**   - 避免重复计算(子原型和常量对象各自计算)
**   - 保持垃圾收集的模块化
*/

LUAI_FUNC void luaF_freeproto(lua_State *L, Proto *f);
/*
** 释放一个函数原型占用的内存
** 参数:
**   L: Lua执行状态指针
**   f: Proto指针，要释放的函数原型
** 返回值: 无
**
** 工作原理:
**   - 这是luaF_protosize()的配套函数，专门用于垃圾收集
**   - 遍历原型的各个动态分配的数组字段，逐个释放:
**     * 释放字节码数组(code)
**     * 释放常量表(k)
**     * 释放嵌套原型指针数组(p)
**     * 释放上值描述信息(upvalues)
**     * 释放调试信息(lineinfo, locvars)
**   - 最后释放Proto结构体本身
**
** 调用时机:
**   仅由垃圾收集系统调用，当一个原型变为不可达时。
**
** 与luaF_newproto的对应:
**   - luaF_newproto: 分配并初始化一个新原型
**   - luaF_freeproto: 清理并释放一个原型
**
** 内存泄漏风险:
**   如果有任何原型中的指针指向外部数据，必须确保那些指针
**   被正确初始化和释放(这是分配内存的代码的责任)。
**
** 与嵌套原型的关系:
**   本函数释放的是原型的"声明"(包含嵌套原型的指针)。
**   嵌套原型对象本身由垃圾收集器单独处理(它们是独立的GC对象)。
*/

/*
** ===================================================================
** 函数声明: 调试支持
** ===================================================================
*/

LUAI_FUNC const char *luaF_getlocalname(const Proto *func, int local_number,
										int pc);
/*
** 获取函数在给定执行点处的局部变量名称
** 参数:
**   func: Proto指针，要查询的函数原型
**   local_number: 局部变量编号(从1开始计数)
**                 1表示第一个局部变量，2表示第二个，等等
**   pc: 程序计数器(Program Counter)，表示字节码指令的位置
**       pc < func->sizelineinfo 时有效
** 返回值:
**   指向变量名C字符串的指针。
**   如果无法找到该局部变量的名称，返回NULL。
**
** 工作原理:
**   - 原型包含一个locvars数组，记录所有局部变量的信息
**   - 每个元素包含:
**     * varname: 变量名字符串
**     * startpc: 变量开始可用的指令位置
**     * endpc: 变量结束可用的指令位置
**   - 函数在locvars数组中查找:
**     * 第local_number个变量
**     * 该变量的作用域包含pc(startpc <= pc < endpc)
**   - 如果找到，返回varname；否则返回NULL
**
** 场景示例:
**   function foo(x, y)
**     local a, b = 1, 2
**     return x + a
**   end
**
**   原型的局部变量列表:
**   1. "x" (参数)
**   2. "y" (参数)
**   3. "a" (局部变量)
**   4. "b" (局部变量)
**
**   调用 luaF_getlocalname(func, 3, pc) 可能返回 "a" (如果pc在其作用域内)
**
** 使用场景:
**   - 调试器(debugger)需要显示栈跟踪中的变量名
**   - Lua的debug库使用此函数
**   - 错误消息中显示有意义的变量名
**
** 设计特点:
**   - 仅查询参数(不修改状态)，可以随时安全调用
**   - O(1)时间复杂度(直接索引或小范围搜索)
**   - 编译器需要生成正确的locvars数据
**
** 调试信息的生成:
**   Lua编译器在编译时生成locvars信息。
**   可以通过luaU_dumpinfo()等函数查看(如果启用了调试符号)。
*/

#endif
/*
** ===================================================================
** 文件尾部总结
** ===================================================================
**
** 本文件lfunc.h是Lua虚拟机中处理函数原型和闭包的核心接口定义。
**
** 核心概念回顾:
**
** 1. 函数原型(Proto)
**    - 函数的"编译产物"，包含字节码、常量、嵌套函数等
**    - 是"代码"的表示，不包含运行时状态
**    - 一个函数定义对应一个Proto对象
**
** 2. 闭包(Closure)
**    - Proto的"运行时实例"
**    - C闭包(CClosure): 包装C函数，包含上值
**    - Lua闭包(LClosure): 包装Proto，包含上值
**    - 多个闭包可以从同一Proto创建(相同代码，不同上值)
**
** 3. 上值(UpVal)
**    - 代表闭包捕获的外部作用域中的变量
**    - 打开状态: 指向栈上的活动变量
**    - 关闭状态: 保存了值的副本，变量已离开作用域
**
** 4. 生命周期流程
**    编译 -> Proto对象 -> 实例化 -> LClosure对象 -> 捕获上值 -> 关闭/释放
**
** 关键函数分类:
**
** A. 创建函数(分配内存):
**    - luaF_newproto(): 创建新的函数原型
**    - luaF_newCclosure(): 创建C闭包
**    - luaF_newLclosure(): 创建Lua闭包
**
** B. 初始化函数:
**    - luaF_initupvals(): 初始化闭包的上值
**
** C. 上值管理:
**    - luaF_findupval(): 查找或创建上值
**    - luaF_newtbcupval(): 创建待关闭上值
**    - luaF_closeupval(): 关闭上值
**    - luaF_close(): 关闭上值(处理异常)
**    - luaF_unlinkupval(): 从链表移除上值
**
** D. 内存管理:
**    - luaF_protosize(): 计算原型内存大小
**    - luaF_freeproto(): 释放原型
**
** E. 调试支持:
**    - luaF_getlocalname(): 获取局部变量名
**
** 高级特性:
**
** 1. 闭包缓存优化
**    - 原型维护一个闭包缓存(通过MAXMISS控制启用)
**    - 避免频繁创建相同的闭包
**    - 性能优化的例子
**
** 2. 待关闭变量(Lua 5.4+)
**    - 通过<close>属性标记
**    - 离开作用域时自动调用__close方法
**    - 资源管理的新机制
**
** 3. 双链表式上值管理
**    - twups链表追踪包含未关闭上值的线程
**    - 全局打开上值链表按栈位置排序
**    - 支持高效的插入、删除、查找
**
** 设计原则:
**
** 1. 分离关注
**    - Proto(代码)与Closure(实例)分开
**    - 上值的打开/关闭状态明确区分
**    - C与Lua闭包用不同的结构体
**
** 2. 垃圾收集友好
**    - 所有动态分配的对象都可被GC管理
**    - protosize()和freeproto()配对实现精确回收
**    - 上值链表便于GC的扫描
**
** 3. 效率优化
**    - 宏定义用于编译时计算和检查
**    - 链表用于快速插入/删除
**    - 缓存用于减少重复创建
**
** 与虚拟机的关系:
**
** - 虚拟机执行Lua字节码时需要根据Proto进行解释
** - 创建闭包时需要luaF_newLclosure()
** - 函数返回时需要luaF_closeupval()关闭上值
** - 垃圾收集时需要luaF_freeproto()清理
**
** 学习建议:
**
** 1. 先理解Proto与LClosure的区别
** 2. 理解上值的打开/关闭状态机制
** 3. 研究闭包捕获变量的过程
** 4. 理解垃圾收集如何使用这些接口
** 5. 对比C闭包与Lua闭包的实现差异
**
** ===================================================================
*/